function l(i){if(!i)throw new Error("Assertion failed.")}var _=i=>i&&i[i.length-1],Q=i=>i>=0&&i<2**32,E=(i,e,t)=>{let r=0;for(let s=e;s<t;s++){let a=Math.floor(s/8),n=i[a],c=7-(s&7),o=(n&1<<c)>>c;r<<=1,r|=o}return r},Ft=(i,e,t,r)=>{for(let s=e;s<t;s++){let a=Math.floor(s/8),n=i[a],c=7-(s&7);n&=~(1<<c),n|=(r&1<<t-s-1)>>t-s-1<<c,i[a]=n}},K=i=>i instanceof ArrayBuffer?new Uint8Array(i):new Uint8Array(i.buffer,i.byteOffset,i.byteLength),D=new TextEncoder,Ze=i=>Object.fromEntries(Object.entries(i).map(([e,t])=>[t,e])),$={bt709:1,bt470bg:5,smpte170m:6},Mt=Ze($),j={bt709:1,smpte170m:6,"iec61966-2-1":13},Vt=Ze(j),q={rgb:0,bt709:1,bt470bg:5,smpte170m:6},Dt=Ze(q),ye=i=>!!i&&!!i.primaries&&!!i.transfer&&!!i.matrix&&i.fullRange!==void 0,Je=i=>i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer||ArrayBuffer.isView(i)&&!(i instanceof DataView),H=class{currentPromise=Promise.resolve();async acquire(){let e,t=new Promise(s=>{e=s}),r=this.currentPromise;return this.currentPromise=t,await r,e}},L=i=>{let e=i*(Math.PI/180),t=Math.cos(e),r=Math.sin(e);return[t,r,0,-r,t,0,0,0,1]},et=L(0),Pt=i=>[...i].map(e=>e.toString(16).padStart(2,"0")).join(""),zt=i=>(i=i>>1&1431655765|(i&1431655765)<<1,i=i>>2&858993459|(i&858993459)<<2,i=i>>4&252645135|(i&252645135)<<4,i=i>>8&16711935|(i&16711935)<<8,i=i>>16&65535|(i&65535)<<16,i>>>0),B=(i,e,t)=>{let r=0,s=i.length-1,a=-1;for(;r<=s;){let n=r+s>>1,c=t(i[n]);c===e?(a=n,s=n-1):c<e?r=n+1:s=n-1}return a},A=(i,e,t)=>{let r=-1,s=0,a=i.length-1;for(;s<=a;){let n=s+(a-s+1)/2|0;t(i[n])<=e?(r=n,s=n+1):a=n-1}return r},F=()=>{let i,e;return{promise:new Promise((r,s)=>{i=r,e=s}),resolve:i,reject:e}},Ut=(i,e)=>{let t=i.indexOf(e);t!==-1&&i.splice(t,1)},Bt=async function*(i){Symbol.iterator in i?yield*i[Symbol.iterator]():yield*i[Symbol.asyncIterator]()};var le=/(?:(.+?)\n)?((?:\d{2}:)?\d{2}:\d{2}.\d{3})\s+-->\s+((?:\d{2}:)?\d{2}:\d{2}.\d{3})/g,hr=/^WEBVTT(.|\n)*?\n{2}/,ee=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,ve=class{options;preambleText=null;preambleEmitted=!1;constructor(e){this.options=e}parse(e){e=e.replaceAll(`\r
`,`
`).replaceAll("\r",`
`),le.lastIndex=0;let t;if(!this.preambleText){if(!hr.test(e)){let s=new Error("WebVTT preamble incorrect.");throw this.options.error(s),s}t=le.exec(e);let r=e.slice(0,t?.index??e.length).trimEnd();if(!r){let s=new Error("No WebVTT preamble provided.");throw this.options.error(s),s}this.preambleText=r,t&&(e=e.slice(t.index),le.lastIndex=0)}for(;t=le.exec(e);){let r=e.slice(0,t.index),s=t[1],a=t.index+t[0].length,n=e.indexOf(`
`,a)+1,c=e.slice(a,n).trim(),o=e.indexOf(`

`,a);o===-1&&(o=e.length);let u=Ie(t[2]),d=Ie(t[3])-u,h=e.slice(n,o).trim();e=e.slice(o).trimStart(),le.lastIndex=0;let g={timestamp:u/1e3,duration:d/1e3,text:h,identifier:s,settings:c,notes:r},b={};this.preambleEmitted||(b.config={description:this.preambleText},this.preambleEmitted=!0),this.options.output(g,b)}}},br=/(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})/,Ie=i=>{let e=br.exec(i);if(!e)throw new Error("Expected match.");return 60*60*1e3*Number(e[1]||"0")+60*1e3*Number(e[2])+1e3*Number(e[3])+Number(e[4])},Ae=i=>{let e=Math.floor(i/36e5),t=Math.floor(i%(60*60*1e3)/(60*1e3)),r=Math.floor(i%(60*1e3)/1e3),s=i%1e3;return e.toString().padStart(2,"0")+":"+t.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+"."+s.toString().padStart(3,"0")};var de=class{constructor(e){this.writer=e}helper=new Uint8Array(8);helperView=new DataView(this.helper.buffer);offsets=new WeakMap;writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let t=0;t<e.length;t++)this.helperView.setUint8(t%8,e.charCodeAt(t)),t%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{let t=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(let a of e.children)a&&this.writeBox(a);let r=this.writer.getPos(),s=e.size??r-t;this.writer.seek(t),this.writeBoxHeader(e,s),this.writer.seek(r)}}writeBoxHeader(e,t){this.writeU32(e.largeSize?1:t),this.writeAscii(e.type),e.largeSize&&this.writeU64(t)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){let t=this.offsets.get(e);l(t!==void 0);let r=this.writer.getPos();this.writer.seek(t),this.writeBox(e),this.writer.seek(r)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let t=this.measureBoxHeader(e);if(e.contents&&(t+=e.contents.byteLength),e.children)for(let r of e.children)r&&(t+=this.measureBox(r));return t}}},T=new Uint8Array(8),U=new DataView(T.buffer),I=i=>[(i%256+256)%256],x=i=>(U.setUint16(0,i,!1),[T[0],T[1]]),gr=i=>(U.setInt16(0,i,!1),[T[0],T[1]]),Nt=i=>(U.setUint32(0,i,!1),[T[1],T[2],T[3]]),p=i=>(U.setUint32(0,i,!1),[T[0],T[1],T[2],T[3]]),Ht=i=>(U.setInt32(0,i,!1),[T[0],T[1],T[2],T[3]]),X=i=>(U.setUint32(0,Math.floor(i/2**32),!1),U.setUint32(4,i,!1),[T[0],T[1],T[2],T[3],T[4],T[5],T[6],T[7]]),it=i=>(U.setInt16(0,2**8*i,!1),[T[0],T[1]]),z=i=>(U.setInt32(0,2**16*i,!1),[T[0],T[1],T[2],T[3]]),tt=i=>(U.setInt32(0,2**30*i,!1),[T[0],T[1],T[2],T[3]]),rt=(i,e)=>{let t=[],r=i;do{let s=r&127;r>>=7,t.length>0&&(s|=128),t.push(s),e!==void 0&&e--}while(r>0||e);return t.reverse()},M=(i,e=!1)=>{let t=Array(i.length).fill(null).map((r,s)=>i.charCodeAt(s));return e&&t.push(0),t},st=i=>{let e=null;for(let t of i)(!e||t.timestamp>e.timestamp)&&(e=t);return e},Lt=i=>[z(i[0]),z(i[1]),tt(i[2]),z(i[3]),z(i[4]),tt(i[5]),z(i[6]),z(i[7]),tt(i[8])],S=(i,e,t)=>({type:i,contents:e&&new Uint8Array(e.flat(10)),children:t}),y=(i,e,t,r,s)=>S(i,[I(e),Nt(t),r??[]],s),Qt=i=>i.fragmented?S("ftyp",[M("iso5"),p(512),M("iso5"),M("iso6"),M("mp41")]):S("ftyp",[M("isom"),p(512),M("isom"),i.holdsAvc?M("avc1"):[],M("mp41")]),Oe=i=>({type:"mdat",largeSize:i}),Kt=i=>({type:"free",size:i}),fe=(i,e,t=!1)=>S("moov",void 0,[kr(e,i),...i.map(r=>Tr(r,e)),t?Zr(i):null]),kr=(i,e)=>{let t=P(Math.max(0,...e.filter(n=>n.samples.length>0).map(n=>{let c=st(n.samples);return c.timestamp+c.duration})),Re),r=Math.max(0,...e.map(n=>n.track.id))+1,s=!Q(i)||!Q(t),a=s?X:p;return y("mvhd",+s,0,[a(i),a(i),p(Re),a(t),z(1),it(1),Array(10).fill(0),Lt(et),Array(24).fill(0),p(r)])},Tr=(i,e)=>S("trak",void 0,[xr(i,e),Cr(i,e)]),xr=(i,e)=>{let t=st(i.samples),r=P(t?t.timestamp+t.duration:0,Re),s=!Q(e)||!Q(r),a=s?X:p,n;if(i.type==="video"){let c=i.track.metadata.rotation;n=c===void 0||typeof c=="number"?L(c??0):c}else n=et;return y("tkhd",+s,3,[a(e),a(e),p(i.track.id),p(0),a(r),Array(8).fill(0),x(0),x(i.track.id),it(i.type==="audio"?1:0),x(0),Lt(n),z(i.type==="video"?i.info.width:0),z(i.type==="video"?i.info.height:0)])},Cr=(i,e)=>S("mdia",void 0,[Sr(i,e),vr(i),Ir(i)]),Sr=(i,e)=>{let t=st(i.samples),r=P(t?t.timestamp+t.duration:0,i.timescale),s=!Q(e)||!Q(r),a=s?X:p;return y("mdhd",+s,0,[a(e),a(e),p(i.timescale),a(r),x(21956),x(0)])},wr={video:"vide",audio:"soun",subtitle:"text"},yr={video:"VideoHandler",audio:"SoundHandler",subtitle:"TextHandler"},vr=i=>y("hdlr",0,0,[M("mhlr"),M(wr[i.type]),p(0),p(0),p(0),M(yr[i.type],!0)]),Ir=i=>S("minf",void 0,[_r[i.type](),Er(),Vr(i)]),Ar=()=>y("vmhd",0,1,[x(0),x(0),x(0),x(0)]),Rr=()=>y("smhd",0,0,[x(0),x(0)]),Or=()=>y("nmhd",0,0),_r={video:Ar,audio:Rr,subtitle:Or},Er=()=>S("dinf",void 0,[Fr()]),Fr=()=>y("dref",0,0,[p(1)],[Mr()]),Mr=()=>y("url ",0,1),Vr=i=>{let e=i.compositionTimeOffsetTable.length>1||i.compositionTimeOffsetTable.some(t=>t.sampleCompositionTimeOffset!==0);return S("stbl",void 0,[Dr(i),$r(i),jr(i),qr(i),Xr(i),Gr(i),e?Yr(i):null])},Dr=i=>{let e;return i.type==="video"?e=Pr(oi[i.track.source._codec],i):i.type==="audio"?e=Nr(ui[i.track.source._codec],i):i.type==="subtitle"&&(e=Qr(li[i.track.source._codec],i)),l(e),y("stsd",0,0,[p(1)],[e])},Pr=(i,e)=>S(i,[Array(6).fill(0),x(1),x(0),x(0),Array(12).fill(0),x(e.info.width),x(e.info.height),p(4718592),p(4718592),p(0),x(1),Array(32).fill(0),x(24),gr(65535)],[ci[e.track.source._codec](e),ye(e.info.decoderConfig.colorSpace)?zr(e):null]),zr=i=>S("colr",[M("nclx"),x($[i.info.decoderConfig.colorSpace.primaries]),x(j[i.info.decoderConfig.colorSpace.transfer]),x(q[i.info.decoderConfig.colorSpace.matrix]),I((i.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),Ur=i=>i.info.decoderConfig&&S("avcC",[...K(i.info.decoderConfig.description)]),Br=i=>i.info.decoderConfig&&S("hvcC",[...K(i.info.decoderConfig.description)]),Wt=i=>{if(!i.info.decoderConfig)return null;let e=i.info.decoderConfig;l(e.colorSpace);let t=e.codec.split("."),r=Number(t[1]),s=Number(t[2]),c=(Number(t[3])<<4)+(0<<1)+Number(e.colorSpace.fullRange);return y("vpcC",1,0,[I(r),I(s),I(c),I(2),I(2),I(2),x(0)])},Wr=()=>S("av1C",[129,0,0,0]),Nr=(i,e)=>S(i,[Array(6).fill(0),x(1),x(0),x(0),p(0),x(e.info.numberOfChannels),x(16),x(0),x(0),z(e.info.sampleRate)],[mi[e.track.source._codec](e)]),Hr=i=>{let t=[...K(i.info.decoderConfig.description??new ArrayBuffer(0))];return t=[...I(64),...I(21),...Nt(0),...p(0),...p(0),...I(5),...rt(t.length),...t],t=[...x(1),...I(0),...I(4),...rt(t.length),...t,...I(6),...I(1),...I(2)],t=[...I(3),...rt(t.length),...t],y("esds",0,0,t)},Lr=i=>{let e=3840,t=0,r=i.info.decoderConfig?.description;if(r){l(r.byteLength>=18);let s=ArrayBuffer.isView(r)?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(r);e=s.getUint16(10,!0),t=s.getInt16(14,!0)}return S("dOps",[I(0),I(i.info.numberOfChannels),x(e),p(i.info.sampleRate),it(t),I(0)])},Qr=(i,e)=>S(i,[Array(6).fill(0),x(1)],[di[e.track.source._codec](e)]),Kr=i=>S("vttC",[...D.encode(i.info.config.description)]);var $r=i=>y("stts",0,0,[p(i.timeToSampleTable.length),i.timeToSampleTable.map(e=>[p(e.sampleCount),p(e.sampleDelta)])]),jr=i=>{if(i.samples.every(t=>t.type==="key"))return null;let e=[...i.samples.entries()].filter(([,t])=>t.type==="key");return y("stss",0,0,[p(e.length),e.map(([t])=>p(t+1))])},qr=i=>y("stsc",0,0,[p(i.compactlyCodedChunkTable.length),i.compactlyCodedChunkTable.map(e=>[p(e.firstChunk),p(e.samplesPerChunk),p(1)])]),Xr=i=>y("stsz",0,0,[p(0),p(i.samples.length),i.samples.map(e=>p(e.size))]),Gr=i=>i.finalizedChunks.length>0&&_(i.finalizedChunks).offset>=2**32?y("co64",0,0,[p(i.finalizedChunks.length),i.finalizedChunks.map(e=>X(e.offset))]):y("stco",0,0,[p(i.finalizedChunks.length),i.finalizedChunks.map(e=>p(e.offset))]),Yr=i=>y("ctts",0,0,[p(i.compositionTimeOffsetTable.length),i.compositionTimeOffsetTable.map(e=>[p(e.sampleCount),p(e.sampleCompositionTimeOffset)])]),Zr=i=>S("mvex",void 0,i.map(Jr)),Jr=i=>y("trex",0,0,[p(i.track.id),p(1),p(0),p(0),p(0)]),at=(i,e)=>S("moof",void 0,[ei(i),...e.map(ti)]),ei=i=>y("mfhd",0,0,[p(i)]),$t=i=>{let e=0,t=0,r=0,s=0,a=i.type==="delta";return t|=+a,a?e|=1:e|=2,e<<24|t<<16|r<<8|s},ti=i=>S("traf",void 0,[ri(i),ii(i),si(i)]),ri=i=>{l(i.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;let t=i.currentChunk.samples[1]??i.currentChunk.samples[0],r={duration:t.timescaleUnitsToNextSample,size:t.size,flags:$t(t)};return y("tfhd",0,e,[p(i.track.id),p(r.duration),p(r.size),p(r.flags)])},ii=i=>(l(i.currentChunk),y("tfdt",1,0,[X(P(i.currentChunk.startTimestamp,i.timescale))])),si=i=>{l(i.currentChunk);let e=i.currentChunk.samples.map(f=>f.timescaleUnitsToNextSample),t=i.currentChunk.samples.map(f=>f.size),r=i.currentChunk.samples.map($t),s=i.currentChunk.samples.map(f=>P(f.timestamp-f.decodeTimestamp,i.timescale)),a=new Set(e),n=new Set(t),c=new Set(r),o=new Set(s),u=c.size===2&&r[0]!==r[1],m=a.size>1,d=n.size>1,h=!u&&c.size>1,g=o.size>1||[...o].some(f=>f!==0),b=0;return b|=1,b|=4*+u,b|=256*+m,b|=512*+d,b|=1024*+h,b|=2048*+g,y("trun",1,b,[p(i.currentChunk.samples.length),p(i.currentChunk.offset-i.currentChunk.moofOffset||0),u?p(r[0]):[],i.currentChunk.samples.map((f,k)=>[m?p(e[k]):[],d?p(t[k]):[],h?p(r[k]):[],g?Ht(s[k]):[]])])},jt=i=>S("mfra",void 0,[...i.map(ai),ni()]),ai=(i,e)=>y("tfra",1,0,[p(i.track.id),p(63),p(i.finalizedChunks.length),i.finalizedChunks.map(r=>[X(P(r.samples[0].timestamp,i.timescale)),X(r.moofOffset),p(e+1),p(1),p(1)])]),ni=()=>y("mfro",0,0,[p(0)]),qt=()=>S("vtte"),Xt=(i,e,t,r,s)=>S("vttc",void 0,[s!==null?S("vsid",[Ht(s)]):null,t!==null?S("iden",[...D.encode(t)]):null,e!==null?S("ctim",[...D.encode(Ae(e))]):null,r!==null?S("sttg",[...D.encode(r)]):null,S("payl",[...D.encode(i)])]),Gt=i=>S("vtta",[...D.encode(i)]),oi={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},ci={avc:Ur,hevc:Br,vp8:Wt,vp9:Wt,av1:Wr},ui={aac:"mp4a",opus:"Opus"},mi={aac:Hr,opus:Lr},li={webvtt:"wvtt"},di={webvtt:Kr};var te=class{output;mutex=new H;constructor(e){this.output=e}beforeTrackAdd(e){}onTrackClose(e){}trackTimestampInfo=new WeakMap;validateAndNormalizeTimestamp(e,t,r){let s=t/1e6,a=this.trackTimestampInfo.get(e);if(!a){if(!r)throw new Error("First frame must be a key frame.");if(this.timestampsMustStartAtZero&&s>0)throw new Error(`Timestamps must start at zero (got ${s}s).`);a={timestampOffset:s,maxTimestamp:e.source._offsetTimestamps?0:s,lastKeyFrameTimestamp:e.source._offsetTimestamps?0:s},this.trackTimestampInfo.set(e,a)}if(e.source._offsetTimestamps&&(s-=a.timestampOffset),s<0)throw new Error(`Timestamps must be non-negative (got ${s}s).`);if(s<a.lastKeyFrameTimestamp)throw new Error(`Timestamp cannot be smaller than last key frame's timestamp (got ${s}s, last key frame at ${a.lastKeyFrameTimestamp}s).`);if(r){if(s<a.maxTimestamp)throw new Error(`Key frame timestamps cannot be smaller than any timestamp that came before (got ${s}s, max timestamp was ${a.maxTimestamp}s).`);a.lastKeyFrameTimestamp=s}return a.maxTimestamp=Math.max(a.maxTimestamp,s),s}};var pe=class{ensureMonotonicity=!1;start(){}},re=class extends pe{pos=0;target;buffer=new ArrayBuffer(2**16);bytes=new Uint8Array(this.buffer);maxPos=0;constructor(e){super(),this.target=e}ensureSize(e){let t=this.buffer.byteLength;for(;t<e;)t*=2;if(t===this.buffer.byteLength)return;let r=new ArrayBuffer(t),s=new Uint8Array(r);s.set(this.bytes,0),this.buffer=r,this.bytes=s}write(e){this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}getSlice(e,t){return this.bytes.slice(e,t)}},_e=class extends pe{pos=0;target;sections=[];lastFlushEnd=0;writer=null;constructor(e){super(),this.target=e}start(){this.writer=this.target._writable.getWriter()}write(e){this.sections.push({data:e.slice(),start:this.pos}),this.pos+=e.byteLength}seek(e){this.pos=e}getPos(){return this.pos}async flush(){if(l(this.writer),this.sections.length===0)return;let e=[],t=[...this.sections].sort((r,s)=>r.start-s.start);e.push({start:t[0].start,size:t[0].data.byteLength});for(let r=1;r<t.length;r++){let s=e[e.length-1],a=t[r];a.start<=s.start+s.size?s.size=Math.max(s.size,a.start+a.data.byteLength-s.start):e.push({start:a.start,size:a.data.byteLength})}for(let r of e){r.data=new Uint8Array(r.size);for(let s of this.sections)r.start<=s.start&&s.start<r.start+r.size&&r.data.set(s.data,s.start-r.start);if(this.ensureMonotonicity&&r.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.writer.write({type:"write",data:r.data,position:r.start}),this.lastFlushEnd=r.start+r.data.byteLength}this.sections.length=0}finalize(){return l(this.writer),this.writer.close()}},fi=2**24,pi=2,Ee=class extends pe{pos=0;target;chunkSize;chunks=[];lastFlushEnd=0;writer=null;flushedChunkQueue=[];constructor(e){if(super(),this.target=e,this.chunkSize=e._options?.chunkSize??fi,!Number.isInteger(this.chunkSize)||this.chunkSize<2**10)throw new Error("Invalid StreamTarget options: chunkSize must be an integer not smaller than 1024.")}start(){this.writer=this.target._writable.getWriter()}write(e){this.writeDataIntoChunks(e,this.pos),this.queueChunksForFlush(),this.pos+=e.byteLength}seek(e){this.pos=e}getPos(){return this.pos}writeDataIntoChunks(e,t){let r=this.chunks.findIndex(o=>o.start<=t&&t<o.start+this.chunkSize);r===-1&&(r=this.createChunk(t));let s=this.chunks[r],a=t-s.start,n=e.subarray(0,Math.min(this.chunkSize-a,e.byteLength));s.data.set(n,a);let c={start:a,end:a+n.byteLength};if(this.insertSectionIntoChunk(s,c),s.written[0].start===0&&s.written[0].end===this.chunkSize&&(s.shouldFlush=!0),this.chunks.length>pi){for(let o=0;o<this.chunks.length-1;o++)this.chunks[o].shouldFlush=!0;this.queueChunksForFlush()}n.byteLength<e.byteLength&&this.writeDataIntoChunks(e.subarray(n.byteLength),t+n.byteLength)}insertSectionIntoChunk(e,t){let r=0,s=e.written.length-1,a=-1;for(;r<=s;){let n=Math.floor(r+(s-r+1)/2);e.written[n].start<=t.start?(r=n+1,a=n):s=n-1}for(e.written.splice(a+1,0,t),(a===-1||e.written[a].end<t.start)&&a++;a<e.written.length-1&&e.written[a].end>=e.written[a+1].start;)e.written[a].end=Math.max(e.written[a].end,e.written[a+1].end),e.written.splice(a+1,1)}createChunk(e){let r={start:Math.floor(e/this.chunkSize)*this.chunkSize,data:new Uint8Array(this.chunkSize),written:[],shouldFlush:!1};return this.chunks.push(r),this.chunks.sort((s,a)=>s.start-a.start),this.chunks.indexOf(r)}queueChunksForFlush(e=!1){l(this.writer);for(let t=0;t<this.chunks.length;t++){let r=this.chunks[t];if(!(!r.shouldFlush&&!e)){for(let s of r.written){if(this.ensureMonotonicity&&r.start+s.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.flushedChunkQueue.push({type:"write",data:r.data.subarray(s.start,s.end),position:r.start+s.start}),this.lastFlushEnd=r.start+s.end}this.chunks.splice(t--,1)}}}async flush(){if(l(this.writer),this.flushedChunkQueue.length!==0){for(let e of this.flushedChunkQueue)this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.writer.write(e);this.flushedChunkQueue.length=0}}async finalize(){return l(this.writer),this.queueChunksForFlush(!0),await this.flush(),this.writer.close()}};var G=class{_output=null},he=class extends G{buffer=null;_createWriter(){return new re(this)}},nt=class extends G{_writable;_options;constructor(e,t={}){if(super(),!(e instanceof WritableStream))throw new TypeError("StreamTarget requires a WritableStream instance.");if(t!=null&&typeof t!="object")throw new TypeError("StreamTarget options, when provided, must be an object.");if(t.chunked!==void 0&&typeof t.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(t.chunkSize!==void 0&&(!Number.isInteger(t.chunkSize)||t.chunkSize<=0))throw new TypeError("options.chunkSize, when provided, must be a positive integer.");this._writable=e,this._options=t}_createWriter(){return this._options.chunked?new Ee(this):new _e(this)}};var ie=["avc","hevc","vp8","vp9","av1"],se=["aac","opus"],Fe=["webvtt"],Yt=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],Zt=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],Jt=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],er=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],tr=(i,e,t,r)=>{if(i==="avc"){let a=Math.ceil(e/16)*Math.ceil(t/16),n=Yt.find(d=>a<=d.maxMacroblocks&&r<=d.maxBitrate)??_(Yt),c=n?n.level:0,o="64".padStart(2,"0"),u="00",m=c.toString(16).padStart(2,"0");return`avc1.${o}${u}${m}`}else if(i==="hevc"){let s="",n="6",c=e*t,o=Zt.find(m=>c<=m.maxPictureSize&&r<=m.maxBitrate)??_(Zt);return`hev1.${s}1.${n}.${o.tier}${o.level}.B0`}else{if(i==="vp8")return"vp8";if(i==="vp9"){let s="00",a=e*t,n=Jt.find(o=>a<=o.maxPictureSize&&r<=o.maxBitrate)??_(Jt);return`vp09.${s}.${n.level}.08`}else if(i==="av1"){let a=e*t,n=er.find(o=>a<=o.maxPictureSize&&r<=o.maxBitrate)??_(er);return`av01.0.${n.level.toString().padStart(2,"0")}${n.tier}.08`}}throw new TypeError(`Unhandled codec '${i}'.`)},rr=(i,e)=>{if(i==="avc"){if(!e||e.byteLength<4)throw new TypeError("AVC description must be at least 4 bytes long.");return`avc1.${Pt(e.subarray(1,4))}`}else if(i==="hevc"){if(!e)throw new TypeError("HEVC description must be provided.");let t=new DataView(e.buffer,e.byteOffset,e.byteLength),r="hev1.",s=e[1]>>6&3,a=e[1]&31;r+=["","A","B","C"][s]+a,r+=".";let n=zt(t.getUint32(2));r+=n.toString(16),r+=".";let c=e[1]>>5&1,o=e[12];r+=c===0?"L":"H",r+=o,r+=".";let u=[];for(let m=0;m<6;m++){let d=e[m+13];u.push(d)}for(;u[u.length-1]===0;)u.pop();return r+=u.map(m=>m.toString(16)).join("."),r}throw new TypeError(`Unhandled codec '${i}'.`)},ir=(i,e,t)=>{if(i==="aac")return e>=2&&t<=24e3?"mp4a.40.29":t<=24e3?"mp4a.40.5":"mp4a.40.2";if(i==="opus")return"opus";if(i==="vorbis")return"vorbis";throw new TypeError(`Unhandled codec '${i}'.`)},sr=(i,e)=>{if(i==="aac")return`mp4a.40.${ot(e).objectType}`;if(i==="opus")return"opus";if(i==="vorbis")return"vorbis";throw new TypeError(`Unhandled codec '${i}'.`)},ot=i=>{if(!i||i.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");let e=0,t=E(i,e,e+5);e+=5,t===31&&(t=32+E(i,e,e+6),e+=6);let r=E(i,e,e+4);e+=4;let s=null;if(r===15)s=E(i,e,e+24),e+=24;else{let c=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350];r<c.length&&(s=c[r])}let a=E(i,e,e+4);e+=4;let n=null;return a>=1&&a<=7&&(n={1:1,2:2,3:3,4:4,5:5,6:6,7:8}[a]),{objectType:t,frequencyIndex:r,sampleRate:s,channelConfiguration:a,numberOfChannels:n}},ar=i=>i==="avc"?{avc:{format:"avc"}}:i==="hevc"?{hevc:{format:"hevc"}}:{},nr=i=>i==="aac"?{aac:{format:"aac"}}:i==="opus"?{opus:{format:"opus"}}:{},Me=i=>{if(!i)throw new TypeError("Video chunk metadata must be provided.");if(typeof i!="object")throw new TypeError("Video chunk metadata must be an object.");if(!i.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof i.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof i.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!Number.isInteger(i.decoderConfig.codedWidth)||i.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(i.decoderConfig.codedHeight)||i.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(i.decoderConfig.description!==void 0&&!Je(i.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(i.decoderConfig.colorSpace!==void 0){let{colorSpace:e}=i.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");let t=Object.keys($);if(e.primaries!=null&&!t.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${t.join(", ")}.`);let r=Object.keys(j);if(e.transfer!=null&&!r.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${r.join(", ")}.`);let s=Object.keys(q);if(e.matrix!=null&&!s.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${s.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if((i.decoderConfig.codec.startsWith("avc1")||i.decoderConfig.codec.startsWith("avc3"))&&!i.decoderConfig.description)throw new TypeError("Video chunk metadata decoder configuration for AVC must include a description, which is expected to be an AVCDecoderConfigurationRecord as specified in ISO 14496-15.");if((i.decoderConfig.codec.startsWith("hev1")||i.decoderConfig.codec.startsWith("hvc1"))&&!i.decoderConfig.description)throw new TypeError("Video chunk metadata decoder configuration for HEVC must include a description, which is expected to be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15.");if((i.decoderConfig.codec==="vp8"||i.decoderConfig.codec.startsWith("vp09"))&&i.decoderConfig.colorSpace===void 0)throw new TypeError("Video chunk metadata decoder configuration for VP8/VP9 must include a colorSpace.")},Ve=i=>{if(!i)throw new TypeError("Audio chunk metadata must be provided.");if(typeof i!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!i.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof i.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof i.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Number.isInteger(i.decoderConfig.sampleRate)||i.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(i.decoderConfig.numberOfChannels)||i.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(i.decoderConfig.description!==void 0&&!Je(i.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(i.decoderConfig.codec.startsWith("mp4a")&&!i.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.");if(i.decoderConfig.codec==="opus"&&i.decoderConfig.description&&i.decoderConfig.description.byteLength<18)throw new TypeError("Invalid decoder description provided for Opus; must be at least 18 bytes long.")},De=i=>{if(!i)throw new TypeError("Subtitle metadata must be provided.");if(typeof i!="object")throw new TypeError("Subtitle metadata must be an object.");if(!i.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof i.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof i.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};var Re=1e3,hi=2082844800,P=(i,e,t=!0)=>{let r=i*e;return t?Math.round(r):r},Pe=class extends te{timestampsMustStartAtZero=!0;writer;boxWriter;fastStart;auxTarget=new he;auxWriter=this.auxTarget._createWriter();auxBoxWriter=new de(this.auxWriter);ftypSize=null;mdat=null;trackDatas=[];creationTime=Math.floor(Date.now()/1e3)+hi;finalizedChunks=[];nextFragmentNumber=1;constructor(e,t){super(e),this.writer=e._writer,this.boxWriter=new de(this.writer);let r=this.writer instanceof re?"in-memory":!1;this.fastStart=t._options.fastStart??r,(this.fastStart==="in-memory"||this.fastStart==="fragmented")&&(this.writer.ensureMonotonicity=!0)}async start(){let e=await this.mutex.acquire(),t=this.output._tracks.some(r=>r.type==="video"&&r.source._codec==="avc");this.boxWriter.writeBox(Qt({holdsAvc:t,fragmented:this.fastStart==="fragmented"})),this.ftypSize=this.writer.getPos(),this.fastStart==="in-memory"?this.mdat=Oe(!1):this.fastStart==="fragmented"||(this.mdat=Oe(!0),this.boxWriter.writeBox(this.mdat)),await this.writer.flush(),e()}getVideoTrackData(e,t){let r=this.trackDatas.find(a=>a.track===e);if(r)return r;Me(t),l(t),l(t.decoderConfig),l(t.decoderConfig.codedWidth!==void 0),l(t.decoderConfig.codedHeight!==void 0);let s={track:e,type:"video",info:{width:t.decoderConfig.codedWidth,height:t.decoderConfig.codedHeight,decoderConfig:t.decoderConfig},timescale:e.metadata.frameRate??57600,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(s),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),s}getAudioTrackData(e,t){let r=this.trackDatas.find(a=>a.track===e);if(r)return r;Ve(t),l(t),l(t.decoderConfig);let s={track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig},timescale:t.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(s),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),s}getSubtitleTrackData(e,t){let r=this.trackDatas.find(a=>a.track===e);if(r)return r;De(t),l(t),l(t.config);let s={track:e,type:"subtitle",info:{config:t.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(s),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),this.validateAndNormalizeTimestamp(e,0,!0),s}async addEncodedVideoChunk(e,t,r){let s=await this.mutex.acquire();try{let a=this.getVideoTrackData(e,r),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=this.validateAndNormalizeTimestamp(a.track,t.timestamp,t.type==="key"),o=this.createSampleForTrack(a,n,c,(t.duration??0)/1e6,t.type);await this.registerSample(a,o)}finally{s()}}async addEncodedAudioChunk(e,t,r){let s=await this.mutex.acquire();try{let a=this.getAudioTrackData(e,r),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=t.type,o=this.validateAndNormalizeTimestamp(a.track,t.timestamp,c==="key"),u=this.createSampleForTrack(a,n,o,(t.duration??0)/1e6,c);await this.registerSample(a,u)}finally{s()}}async addSubtitleCue(e,t,r){let s=await this.mutex.acquire();try{let a=this.getSubtitleTrackData(e,r);this.validateAndNormalizeTimestamp(a.track,1e6*t.timestamp,!0),e.source._codec==="webvtt"&&(a.cueQueue.push(t),await this.processWebVTTCues(a,t.timestamp))}finally{s()}}async processWebVTTCues(e,t){for(;e.cueQueue.length>0;){let r=new Set([]);for(let u of e.cueQueue)l(u.timestamp<=t),l(e.lastCueEndTimestamp<=u.timestamp+u.duration),r.add(Math.max(u.timestamp,e.lastCueEndTimestamp)),r.add(u.timestamp+u.duration);let s=[...r].sort((u,m)=>u-m),a=s[0],n=s[1]??a;if(t<n)break;if(e.lastCueEndTimestamp<a){this.auxWriter.seek(0);let u=qt();this.auxBoxWriter.writeBox(u);let m=this.auxWriter.getSlice(0,this.auxWriter.getPos()),d=this.createSampleForTrack(e,m,e.lastCueEndTimestamp,a-e.lastCueEndTimestamp,"key");await this.registerSample(e,d),e.lastCueEndTimestamp=a}this.auxWriter.seek(0);for(let u=0;u<e.cueQueue.length;u++){let m=e.cueQueue[u];if(m.timestamp>=n)break;ee.lastIndex=0;let d=ee.test(m.text),h=m.timestamp+m.duration,g=e.cueToSourceId.get(m);if(g===void 0&&n<h&&(g=e.nextSourceId++,e.cueToSourceId.set(m,g)),m.notes){let f=Gt(m.notes);this.auxBoxWriter.writeBox(f)}let b=Xt(m.text,d?a:null,m.identifier??null,m.settings??null,g??null);this.auxBoxWriter.writeBox(b),h===n&&e.cueQueue.splice(u--,1)}let c=this.auxWriter.getSlice(0,this.auxWriter.getPos()),o=this.createSampleForTrack(e,c,a,n-a,"key");await this.registerSample(e,o),e.lastCueEndTimestamp=n}}createSampleForTrack(e,t,r,s,a){return{timestamp:r,decodeTimestamp:r,duration:s,data:t,size:t.byteLength,type:a,timescaleUnitsToNextSample:P(s,e.timescale)}}processTimestamps(e){if(e.timestampProcessingQueue.length===0)return;let t=e.timestampProcessingQueue.map(r=>r.timestamp).sort((r,s)=>r-s);for(let r=0;r<e.timestampProcessingQueue.length;r++){let s=e.timestampProcessingQueue[r];s.decodeTimestamp=t[r];let a=P(s.timestamp-s.decodeTimestamp,e.timescale),n=P(s.duration,e.timescale);if(e.lastTimescaleUnits!==null){l(e.lastSample);let c=P(s.decodeTimestamp,e.timescale,!1),o=Math.round(c-e.lastTimescaleUnits);if(e.lastTimescaleUnits+=o,e.lastSample.timescaleUnitsToNextSample=o,this.fastStart!=="fragmented"){let u=_(e.timeToSampleTable);if(l(u),u.sampleCount===1){u.sampleDelta=o;let d=e.timeToSampleTable[e.timeToSampleTable.length-2];d&&d.sampleDelta===o&&(d.sampleCount++,e.timeToSampleTable.pop(),u=d)}else u.sampleDelta!==o&&(u.sampleCount--,e.timeToSampleTable.push(u={sampleCount:1,sampleDelta:o}));u.sampleDelta===n?u.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:n});let m=_(e.compositionTimeOffsetTable);l(m),m.sampleCompositionTimeOffset===a?m.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a})}}else e.lastTimescaleUnits=0,this.fastStart!=="fragmented"&&(e.timeToSampleTable.push({sampleCount:1,sampleDelta:n}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a}));e.lastSample=s}e.timestampProcessingQueue.length=0}async registerSample(e,t){this.fastStart==="fragmented"?(e.sampleQueue.push(t),await this.interleaveSamples()):await this.addSampleToTrack(e,t)}async addSampleToTrack(e,t){t.type==="key"&&this.processTimestamps(e),this.fastStart!=="fragmented"&&e.samples.push(t);let r=!1;if(!e.currentChunk)r=!0;else{let s=t.timestamp-e.currentChunk.startTimestamp;if(this.fastStart==="fragmented"){let a=this.trackDatas.every(n=>{if(e===n)return t.type==="key";let c=n.sampleQueue[0];return c&&c.type==="key"});s>=1&&a&&(r=!0,await this.finalizeFragment())}else r=s>=.5}r&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:t.timestamp,samples:[],offset:null,moofOffset:null}),l(e.currentChunk),e.currentChunk.samples.push(t),e.timestampProcessingQueue.push(t)}async finalizeCurrentChunk(e){if(l(this.fastStart!=="fragmented"),!!e.currentChunk){if(e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk),(e.compactlyCodedChunkTable.length===0||_(e.compactlyCodedChunkTable).samplesPerChunk!==e.currentChunk.samples.length)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:e.currentChunk.samples.length}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(let t of e.currentChunk.samples)l(t.data),this.writer.write(t.data),t.data=null;await this.writer.flush()}}async interleaveSamples(){l(this.fastStart==="fragmented");for(let e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return;e:for(;;){let e=null,t=1/0;for(let s of this.trackDatas){if(s.sampleQueue.length===0&&!s.track.source._closed)break e;s.sampleQueue.length>0&&s.sampleQueue[0].timestamp<t&&(e=s,t=s.sampleQueue[0].timestamp)}if(!e)break;let r=e.sampleQueue.shift();await this.addSampleToTrack(e,r)}}async finalizeFragment(e=!0){l(this.fastStart==="fragmented");let t=this.nextFragmentNumber++;if(t===1){let o=fe(this.trackDatas,this.creationTime,!0);this.boxWriter.writeBox(o)}let r=this.trackDatas.filter(o=>o.currentChunk),s=this.writer.getPos(),a=at(t,r);this.boxWriter.writeBox(a);{let o=Oe(!1),u=0;for(let d of r)for(let h of d.currentChunk.samples)u+=h.size;let m=this.boxWriter.measureBox(o)+u;m>=2**32&&(o.largeSize=!0,m=this.boxWriter.measureBox(o)+u),o.size=m,this.boxWriter.writeBox(o)}for(let o of r){o.currentChunk.offset=this.writer.getPos(),o.currentChunk.moofOffset=s;for(let u of o.currentChunk.samples)this.writer.write(u.data),u.data=null}let n=this.writer.getPos();this.writer.seek(this.boxWriter.offsets.get(a));let c=at(t,r);this.boxWriter.writeBox(c),this.writer.seek(n);for(let o of r)o.finalizedChunks.push(o.currentChunk),this.finalizedChunks.push(o.currentChunk),o.currentChunk=null;e&&await this.writer.flush()}async onTrackClose(e){let t=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){let r=this.trackDatas.find(s=>s.track===e);r&&await this.processWebVTTCues(r,1/0)}this.fastStart==="fragmented"&&await this.interleaveSamples(),t()}async finalize(){let e=await this.mutex.acquire();for(let t of this.trackDatas)t.type==="subtitle"&&t.track.source._codec==="webvtt"&&await this.processWebVTTCues(t,1/0);if(this.fastStart==="fragmented"){for(let t of this.trackDatas){for(let r of t.sampleQueue)await this.addSampleToTrack(t,r);this.processTimestamps(t)}await this.finalizeFragment(!1)}else for(let t of this.trackDatas)this.processTimestamps(t),await this.finalizeCurrentChunk(t);if(this.fastStart==="in-memory"){l(this.mdat);let t;for(let s=0;s<2;s++){let a=fe(this.trackDatas,this.creationTime),n=this.boxWriter.measureBox(a);t=this.boxWriter.measureBox(this.mdat);let c=this.writer.getPos()+n+t;for(let o of this.finalizedChunks){o.offset=c;for(let{data:u}of o.samples)l(u),c+=u.byteLength,t+=u.byteLength}if(c<2**32)break;t>=2**32&&(this.mdat.largeSize=!0)}let r=fe(this.trackDatas,this.creationTime);this.boxWriter.writeBox(r),this.mdat.size=t,this.boxWriter.writeBox(this.mdat);for(let s of this.finalizedChunks)for(let a of s.samples)l(a.data),this.writer.write(a.data),a.data=null}else if(this.fastStart==="fragmented"){let t=this.writer.getPos(),r=jt(this.trackDatas);this.boxWriter.writeBox(r);let s=this.writer.getPos()-t;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(s)}else{l(this.mdat),l(this.ftypSize!==null);let t=this.boxWriter.offsets.get(this.mdat);l(t!==void 0);let r=this.writer.getPos()-t;this.mdat.size=r,this.mdat.largeSize=r>=2**32,this.boxWriter.patchBox(this.mdat);let s=fe(this.trackDatas,this.creationTime);if(typeof this.fastStart=="object"){this.writer.seek(this.ftypSize),this.boxWriter.writeBox(s);let a=t-this.writer.getPos();this.boxWriter.writeBox(Kt(a))}else this.boxWriter.writeBox(s)}e()}};var be=class{value;constructor(e){this.value=e}},ae=class{value;constructor(e){this.value=e}},ge=class{value;constructor(e){this.value=e}};var ct=i=>i<256?1:i<65536?2:i<1<<24?3:i<2**32?4:i<2**40?5:6,ut=i=>i>=-64&&i<64?1:i>=-8192&&i<8192?2:i>=-(1<<20)&&i<1<<20?3:i>=-(1<<27)&&i<1<<27?4:i>=-(2**34)&&i<2**34?5:6,or=i=>{if(i<127)return 1;if(i<16383)return 2;if(i<(1<<21)-1)return 3;if(i<(1<<28)-1)return 4;if(i<2**35-1)return 5;if(i<2**42-1)return 6;throw new Error("EBML VINT size not supported "+i)};var mt=2**15,cr="https://github.com/Vanilagy/webm-muxer",ur=6,mr=5,bi={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",opus:"A_OPUS",webvtt:"S_TEXT/WEBVTT"},gi={video:1,audio:2,subtitle:17},ze=class extends te{timestampsMustStartAtZero=!1;writer;format;helper=new Uint8Array(8);helperView=new DataView(this.helper.buffer);offsets=new WeakMap;dataOffsets=new WeakMap;trackDatas=[];segment=null;segmentInfo=null;seekHead=null;tracksElement=null;segmentDuration=null;cues=null;currentCluster=null;currentClusterMsTimestamp=null;trackDatasInCurrentCluster=new Set;duration=0;constructor(e,t){super(e),this.writer=e._writer,this.format=t,this.format._options.streamable&&(this.writer.ensureMonotonicity=!0)}writeByte(e){this.helperView.setUint8(0,e),this.writer.write(this.helper.subarray(0,1))}writeFloat32(e){this.helperView.setFloat32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeFloat64(e){this.helperView.setFloat64(0,e,!1),this.writer.write(this.helper)}writeUnsignedInt(e,t=ct(e)){let r=0;switch(t){case 6:this.helperView.setUint8(r++,e/2**40|0);case 5:this.helperView.setUint8(r++,e/2**32|0);case 4:this.helperView.setUint8(r++,e>>24);case 3:this.helperView.setUint8(r++,e>>16);case 2:this.helperView.setUint8(r++,e>>8);case 1:this.helperView.setUint8(r++,e);break;default:throw new Error("Bad UINT size "+t)}this.writer.write(this.helper.subarray(0,r))}writeSignedInt(e,t=ut(e)){e<0&&(e+=2**(t*8)),this.writeUnsignedInt(e,t)}writeEBMLVarInt(e,t=or(e)){let r=0;switch(t){case 1:this.helperView.setUint8(r++,128|e);break;case 2:this.helperView.setUint8(r++,64|e>>8),this.helperView.setUint8(r++,e);break;case 3:this.helperView.setUint8(r++,32|e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 4:this.helperView.setUint8(r++,16|e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 5:this.helperView.setUint8(r++,8|e/2**32&7),this.helperView.setUint8(r++,e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;case 6:this.helperView.setUint8(r++,4|e/2**40&3),this.helperView.setUint8(r++,e/2**32|0),this.helperView.setUint8(r++,e>>24),this.helperView.setUint8(r++,e>>16),this.helperView.setUint8(r++,e>>8),this.helperView.setUint8(r++,e);break;default:throw new Error("Bad EBML VINT size "+t)}this.writer.write(this.helper.subarray(0,r))}writeString(e){this.writer.write(new Uint8Array(e.split("").map(t=>t.charCodeAt(0))))}writeEBML(e){if(e!==null){if(e instanceof Uint8Array)this.writer.write(e);else if(Array.isArray(e))for(let t of e)this.writeEBML(t);else if(this.offsets.set(e,this.writer.getPos()),this.writeUnsignedInt(e.id),Array.isArray(e.data)){let t=this.writer.getPos(),r=e.size===-1?1:e.size??4;e.size===-1?this.writeByte(255):this.writer.seek(this.writer.getPos()+r);let s=this.writer.getPos();if(this.dataOffsets.set(e,s),this.writeEBML(e.data),e.size!==-1){let a=this.writer.getPos()-s,n=this.writer.getPos();this.writer.seek(t),this.writeEBMLVarInt(a,r),this.writer.seek(n)}}else if(typeof e.data=="number"){let t=e.size??ct(e.data);this.writeEBMLVarInt(t),this.writeUnsignedInt(e.data,t)}else if(typeof e.data=="string")this.writeEBMLVarInt(e.data.length),this.writeString(e.data);else if(e.data instanceof Uint8Array)this.writeEBMLVarInt(e.data.byteLength,e.size),this.writer.write(e.data);else if(e.data instanceof be)this.writeEBMLVarInt(4),this.writeFloat32(e.data.value);else if(e.data instanceof ae)this.writeEBMLVarInt(8),this.writeFloat64(e.data.value);else if(e.data instanceof ge){let t=e.size??ut(e.data.value);this.writeEBMLVarInt(t),this.writeSignedInt(e.data.value,t)}}}beforeTrackAdd(e){if(this.format instanceof ne)if(e.type==="video"){if(!["vp8","vp9","av1"].includes(e.source._codec))throw new Error("WebM only supports VP8, VP9 and AV1 as video codecs. Switching to MKV removes this restriction.")}else if(e.type==="audio"){if(!["opus","vorbis"].includes(e.source._codec))throw new Error("WebM only supports Opus and Vorbis as audio codecs. Switching to MKV removes this restriction.")}else if(e.type==="subtitle"){if(e.source._codec!=="webvtt")throw new Error("WebM only supports WebVTT as subtitle codec. Switching to MKV removes this restriction.")}else throw new Error("WebM only supports video, audio and subtitle tracks. Switching to MKV removes this restriction.")}async start(){let e=await this.mutex.acquire();this.writeEBMLHeader(),this.format._options.streamable||this.createSeekHead(),this.createSegmentInfo(),this.createCues(),await this.writer.flush(),e()}writeEBMLHeader(){let e={id:440786851,data:[{id:17030,data:1},{id:17143,data:1},{id:17138,data:4},{id:17139,data:8},{id:17026,data:this.format instanceof ne?"webm":"matroska"},{id:17031,data:2},{id:17029,data:2}]};this.writeEBML(e)}createSeekHead(){let e=new Uint8Array([28,83,187,107]),t=new Uint8Array([21,73,169,102]),r=new Uint8Array([22,84,174,107]),s={id:290298740,data:[{id:19899,data:[{id:21419,data:e},{id:21420,size:5,data:0}]},{id:19899,data:[{id:21419,data:t},{id:21420,size:5,data:0}]},{id:19899,data:[{id:21419,data:r},{id:21420,size:5,data:0}]}]};this.seekHead=s}createSegmentInfo(){let e={id:17545,data:new ae(0)};this.segmentDuration=e;let t={id:357149030,data:[{id:2807729,data:1e6},{id:19840,data:cr},{id:22337,data:cr},this.format._options.streamable?null:e]};this.segmentInfo=t}createTracks(){let e={id:374648427,data:[]};this.tracksElement=e;for(let t of this.trackDatas)e.data.push({id:174,data:[{id:215,data:t.track.id},{id:29637,data:t.track.id},{id:131,data:gi[t.type]},{id:134,data:bi[t.track.source._codec]},t.type==="video"?this.videoSpecificTrackInfo(t):null,t.type==="audio"?this.audioSpecificTrackInfo(t):null,t.type==="subtitle"?this.subtitleSpecificTrackInfo(t):null]})}videoSpecificTrackInfo(e){let t=[e.info.decoderConfig.description?{id:25506,data:K(e.info.decoderConfig.description)}:null,e.track.metadata.frameRate?{id:2352003,data:1e9/e.track.metadata.frameRate}:null],r=e.info.decoderConfig.colorSpace,s={id:224,data:[{id:176,data:e.info.width},{id:186,data:e.info.height},ye(r)?{id:21936,data:[{id:21937,data:q[r.matrix]},{id:21946,data:j[r.transfer]},{id:21947,data:$[r.primaries]},{id:21945,data:r.fullRange?2:1}]}:null]};return t.push(s),t}audioSpecificTrackInfo(e){return[e.info.decoderConfig.description?{id:25506,data:K(e.info.decoderConfig.description)}:null,{id:225,data:[{id:181,data:new be(e.info.sampleRate)},{id:159,data:e.info.numberOfChannels}]}]}subtitleSpecificTrackInfo(e){return[{id:25506,data:D.encode(e.info.config.description)}]}createSegment(){let e={id:408125543,size:this.format._options.streamable?-1:ur,data:[this.format._options.streamable?null:this.seekHead,this.segmentInfo,this.tracksElement]};this.segment=e,this.writeEBML(e)}createCues(){this.cues={id:475249515,data:[]}}get segmentDataOffset(){return l(this.segment),this.dataOffsets.get(this.segment)}getVideoTrackData(e,t){let r=this.trackDatas.find(a=>a.track===e);if(r)return r;Me(t),l(t),l(t.decoderConfig),l(t.decoderConfig.codedWidth!==void 0),l(t.decoderConfig.codedHeight!==void 0);let s={track:e,type:"video",info:{width:t.decoderConfig.codedWidth,height:t.decoderConfig.codedHeight,decoderConfig:t.decoderConfig},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),s}getAudioTrackData(e,t){let r=this.trackDatas.find(a=>a.track===e);if(r)return r;Ve(t),l(t),l(t.decoderConfig);let s={track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),s}getSubtitleTrackData(e,t){let r=this.trackDatas.find(a=>a.track===e);if(r)return r;De(t),l(t),l(t.config);let s={track:e,type:"subtitle",info:{config:t.config},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),s}async addEncodedVideoChunk(e,t,r){let s=await this.mutex.acquire();try{let a=this.getVideoTrackData(e,r),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=t.type==="key",o=this.validateAndNormalizeTimestamp(a.track,t.timestamp,c),u=this.createInternalChunk(n,o,(t.duration??0)/1e6,t.type);e.source._codec==="vp9"&&this.fixVP9ColorSpace(a,u),a.chunkQueue.push(u),await this.interleaveChunks()}finally{s()}}async addEncodedAudioChunk(e,t,r){let s=await this.mutex.acquire();try{let a=this.getAudioTrackData(e,r),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=t.type,o=c==="key",u=this.validateAndNormalizeTimestamp(a.track,t.timestamp,o),m=this.createInternalChunk(n,u,(t.duration??0)/1e6,c);a.chunkQueue.push(m),await this.interleaveChunks()}finally{s()}}async addSubtitleCue(e,t,r){let s=await this.mutex.acquire();try{let a=this.getSubtitleTrackData(e,r),n=this.validateAndNormalizeTimestamp(a.track,1e6*t.timestamp,!0),c=t.text,o=Math.floor(n*1e3);ee.lastIndex=0,c=c.replace(ee,h=>{let b=Ie(h.slice(1,-1))-o;return`<${Ae(b)}>`});let u=D.encode(c),m=`${t.settings??""}
${t.identifier??""}
${t.notes??""}`,d=this.createInternalChunk(u,n,t.duration,"key",m.trim()?D.encode(m):null);a.chunkQueue.push(d),await this.interleaveChunks()}finally{s()}}async interleaveChunks(){for(let e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return;e:for(;;){let e=null,t=1/0;for(let s of this.trackDatas){if(s.chunkQueue.length===0&&!s.track.source._closed)break e;s.chunkQueue.length>0&&s.chunkQueue[0].timestamp<t&&(e=s,t=s.chunkQueue[0].timestamp)}if(!e)break;let r=e.chunkQueue.shift();this.writeBlock(e,r)}await this.writer.flush()}fixVP9ColorSpace(e,t){if(t.type!=="key"||!e.info.decoderConfig.colorSpace||!e.info.decoderConfig.colorSpace.matrix)return;let r=0;if(E(t.data,0,2)!==2)return;r+=2;let s=(E(t.data,r+1,r+2)<<1)+E(t.data,r+0,r+1);r+=2,s===3&&r++;let a=E(t.data,r+0,r+1);if(r++,a)return;let n=E(t.data,r+0,r+1);if(r++,n!==0)return;r+=2;let c=E(t.data,r+0,r+24);if(r+=24,c!==4817730)return;s>=2&&r++;let o={rgb:7,bt709:2,bt470bg:1,smpte170m:3}[e.info.decoderConfig.colorSpace.matrix];Ft(t.data,r+0,r+3,o)}createInternalChunk(e,t,r,s,a=null){return{data:e,type:s,timestamp:t,duration:r,additions:a}}writeBlock(e,t){this.segment||(this.createTracks(),this.createSegment());let r=Math.floor(1e3*t.timestamp),s=this.trackDatas.every(m=>{if(m.track.source._closed)return!0;if(e===m)return t.type==="key";let d=m.chunkQueue[0];return d&&d.type==="key"});(!this.currentCluster||s&&r-this.currentClusterMsTimestamp>=1e3)&&this.createNewCluster(r);let a=r-this.currentClusterMsTimestamp;if(a<0)return;if(a>=mt)throw new Error(`Current Matroska cluster exceeded its maximum allowed length of ${mt} milliseconds. In order to produce a correct WebM file, you must pass in a key frame at least every ${mt} milliseconds.`);let c=new Uint8Array(4),o=new DataView(c.buffer);o.setUint8(0,128|e.track.id),o.setInt16(1,a,!1);let u=Math.floor(1e3*t.duration);if(u===0&&!t.additions){o.setUint8(3,+(t.type==="key")<<7);let m={id:163,data:[c,t.data]};this.writeEBML(m)}else{let m={id:160,data:[{id:161,data:[c,t.data]},t.type==="delta"?{id:251,data:new ge(e.lastWrittenMsTimestamp-r)}:null,t.additions?{id:30113,data:[{id:166,data:[{id:165,data:t.additions},{id:238,data:1}]}]}:null,u>0?{id:155,data:u}:null]};this.writeEBML(m)}this.duration=Math.max(this.duration,r+u),e.lastWrittenMsTimestamp=r,this.trackDatasInCurrentCluster.add(e)}createNewCluster(e){this.currentCluster&&!this.format._options.streamable&&this.finalizeCurrentCluster(),this.currentCluster={id:524531317,size:this.format._options.streamable?-1:mr,data:[{id:231,data:e}]},this.writeEBML(this.currentCluster),this.currentClusterMsTimestamp=e,this.trackDatasInCurrentCluster.clear()}finalizeCurrentCluster(){l(this.currentCluster);let e=this.writer.getPos()-this.dataOffsets.get(this.currentCluster),t=this.writer.getPos();this.writer.seek(this.offsets.get(this.currentCluster)+4),this.writeEBMLVarInt(e,mr),this.writer.seek(t);let r=this.offsets.get(this.currentCluster)-this.segmentDataOffset;l(this.cues),this.cues.data.push({id:187,data:[{id:179,data:this.currentClusterMsTimestamp},...[...this.trackDatasInCurrentCluster].map(s=>({id:183,data:[{id:247,data:s.track.id},{id:241,data:r}]}))]})}async onTrackClose(){let e=await this.mutex.acquire();await this.interleaveChunks(),e()}async finalize(){let e=await this.mutex.acquire();this.segment||(this.createTracks(),this.createSegment());for(let t of this.trackDatas)for(;t.chunkQueue.length>0;)this.writeBlock(t,t.chunkQueue.shift());if(!this.format._options.streamable&&this.currentCluster&&this.finalizeCurrentCluster(),l(this.cues),this.writeEBML(this.cues),!this.format._options.streamable){let t=this.writer.getPos(),r=this.writer.getPos()-this.segmentDataOffset;this.writer.seek(this.offsets.get(this.segment)+4),this.writeEBMLVarInt(r,ur),this.segmentDuration.data=new ae(this.duration),this.writer.seek(this.offsets.get(this.segmentDuration)),this.writeEBML(this.segmentDuration),this.seekHead.data[0].data[1].data=this.offsets.get(this.cues)-this.segmentDataOffset,this.seekHead.data[1].data[1].data=this.offsets.get(this.segmentInfo)-this.segmentDataOffset,this.seekHead.data[2].data[1].data=this.offsets.get(this.tracksElement)-this.segmentDataOffset,this.writer.seek(this.offsets.get(this.seekHead)),this.writeEBML(this.seekHead),this.writer.seek(t)}e()}};var Y=class{},lt=class extends Y{_options;constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError('options.fastStart, when provided, must be false, "in-memory", or "fragmented".');super(),this._options=e}_createMuxer(e){return new Pe(e,this)}},Ue=class extends Y{_options;constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.streamable!==void 0&&typeof e.streamable!="boolean")throw new TypeError("options.streamable, when provided, must be a boolean.");super(),this._options=e}_createMuxer(e){return new ze(e,this)}},ne=class extends Ue{};var oe=class{_connectedTrack=null;_closed=!1;_offsetTimestamps=!1;_ensureValidDigest(){if(!this._connectedTrack)throw new Error("Cannot call digest without connecting the source to an output track.");if(!this._connectedTrack.output._started)throw new Error("Cannot call digest before output has been started.");if(this._connectedTrack.output._finalizing)throw new Error("Cannot call digest after output has started finalizing.");if(this._closed)throw new Error("Cannot call digest after source has been closed.")}_start(){}async _flush(){}close(){if(this._closed)throw new Error("Source already closed.");if(!this._connectedTrack)throw new Error("Cannot call close without connecting the source to an output track.");if(!this._connectedTrack.output._started)throw new Error("Cannot call close before output has been started.");this._closed=!0,!this._connectedTrack.output._finalizing&&this._connectedTrack.output._muxer.onTrackClose(this._connectedTrack)}},W=class extends oe{_connectedTrack=null;_codec;constructor(e){if(super(),!ie.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${ie.join(", ")}.`);this._codec=e}},dt=class extends W{constructor(e){super(e)}digest(e,t){if(!(e instanceof EncodedVideoChunk))throw new TypeError("chunk must be an EncodedVideoChunk.");return this._ensureValidDigest(),this._connectedTrack.output._muxer.addEncodedVideoChunk(this._connectedTrack,e,t)}},ki=5,Ti=i=>{if(!i||typeof i!="object")throw new TypeError("Codec config must be an object.");if(!ie.includes(i.codec))throw new TypeError(`Invalid video codec '${i.codec}'. Must be one of: ${ie.join(", ")}.`);if(!Number.isInteger(i.bitrate)||i.bitrate<=0)throw new TypeError("config.bitrate must be a positive integer.");if(i.latencyMode!==void 0&&!["quality","realtime"].includes(i.latencyMode))throw new TypeError("config.latencyMode, when provided, must be 'quality' or 'realtime'.")},ke=class{constructor(e,t){this.source=e;this.codecConfig=t;Ti(t)}encoder=null;muxer=null;lastMultipleOfKeyFrameInterval=-1;lastWidth=null;lastHeight=null;async digest(e){if(this.source._ensureValidDigest(),this.lastWidth!==null&&this.lastHeight!==null){if(e.codedWidth!==this.lastWidth||e.codedHeight!==this.lastHeight)throw new Error(`Video frame size must remain constant. Expected ${this.lastWidth}x${this.lastHeight}, got ${e.codedWidth}x${e.codedHeight}.`)}else this.lastWidth=e.codedWidth,this.lastHeight=e.codedHeight;this.ensureEncoder(e),l(this.encoder);let t=Math.floor(e.timestamp/1e6/ki);this.encoder.encode(e,{keyFrame:t!==this.lastMultipleOfKeyFrameInterval}),this.lastMultipleOfKeyFrameInterval=t,this.encoder.encodeQueueSize>=4&&await new Promise(r=>this.encoder.addEventListener("dequeue",r,{once:!0})),await this.muxer.mutex.currentPromise}ensureEncoder(e){this.encoder||(this.encoder=new VideoEncoder({output:(t,r)=>void this.muxer.addEncodedVideoChunk(this.source._connectedTrack,t,r),error:t=>console.error("Video encode error:",t)}),this.encoder.configure({codec:tr(this.codecConfig.codec,e.codedWidth,e.codedHeight,this.codecConfig.bitrate),width:e.codedWidth,height:e.codedHeight,bitrate:this.codecConfig.bitrate,framerate:this.source._connectedTrack?.metadata.frameRate,latencyMode:this.codecConfig.latencyMode,...ar(this.codecConfig.codec)}),l(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer)}async flush(){this.encoder&&(await this.encoder.flush(),this.encoder.close())}},ft=class extends W{_encoder;constructor(e){super(e.codec),this._encoder=new ke(this,e)}digest(e){if(!(e instanceof VideoFrame))throw new TypeError("videoFrame must be a VideoFrame.");return this._encoder.digest(e)}_flush(){return this._encoder.flush()}},pt=class extends W{_encoder;_canvas;constructor(e,t){if(!(e instanceof HTMLCanvasElement))throw new TypeError("canvas must be an HTMLCanvasElement.");super(t.codec),this._encoder=new ke(this,t),this._canvas=e}digest(e,t=0){if(!Number.isFinite(e)||e<0)throw new TypeError("timestamp must be a non-negative number.");if(!Number.isFinite(t)||t<0)throw new TypeError("duration must be a non-negative number.");let r=new VideoFrame(this._canvas,{timestamp:Math.round(1e6*e),duration:Math.round(1e6*t),alpha:"discard"}),s=this._encoder.digest(r);return r.close(),s}_flush(){return this._encoder.flush()}},ht=class extends W{_encoder;_abortController=null;_track;_offsetTimestamps=!0;constructor(e,t){if(!(e instanceof MediaStreamTrack)||e.kind!=="video")throw new TypeError("track must be a video MediaStreamTrack.");t={...t,latencyMode:"realtime"},super(t.codec),this._encoder=new ke(this,t),this._track=e}_start(){this._abortController=new AbortController;let e=new MediaStreamTrackProcessor({track:this._track}),t=new WritableStream({write:r=>{this._encoder.digest(r),r.close()}});e.readable.pipeTo(t,{signal:this._abortController.signal}).catch(r=>{r instanceof DOMException&&r.name==="AbortError"||console.error("Pipe error:",r)})}async _flush(){this._abortController&&(this._abortController.abort(),this._abortController=null),await this._encoder.flush()}},N=class extends oe{_connectedTrack=null;_codec;constructor(e){if(super(),!se.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${se.join(", ")}.`);this._codec=e}},bt=class extends N{constructor(e){super(e)}digest(e,t){if(!(e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedAudioChunk.");return this._ensureValidDigest(),this._connectedTrack.output._muxer.addEncodedAudioChunk(this._connectedTrack,e,t)}},xi=i=>{if(!i||typeof i!="object")throw new TypeError("Codec config must be an object.");if(!se.includes(i.codec))throw new TypeError(`Invalid audio codec '${i.codec}'. Must be one of: ${se.join(", ")}.`);if(!Number.isInteger(i.bitrate)||i.bitrate<=0)throw new TypeError("config.bitrate must be a positive integer.")},Te=class{constructor(e,t){this.source=e;this.codecConfig=t;xi(t)}encoder=null;muxer=null;lastNumberOfChannels=null;lastSampleRate=null;async digest(e){if(this.source._ensureValidDigest(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;this.ensureEncoder(e),l(this.encoder),this.encoder.encode(e),this.encoder.encodeQueueSize>=4&&await new Promise(t=>this.encoder.addEventListener("dequeue",t,{once:!0})),await this.muxer.mutex.currentPromise}ensureEncoder(e){this.encoder||(this.encoder=new AudioEncoder({output:(t,r)=>void this.muxer.addEncodedAudioChunk(this.source._connectedTrack,t,r),error:t=>console.error("Audio encode error:",t)}),this.encoder.configure({codec:ir(this.codecConfig.codec,e.numberOfChannels,e.sampleRate),numberOfChannels:e.numberOfChannels,sampleRate:e.sampleRate,bitrate:this.codecConfig.bitrate,...nr(this.codecConfig.codec)}),l(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer)}async flush(){this.encoder&&(await this.encoder.flush(),this.encoder.close())}},gt=class extends N{_encoder;constructor(e){super(e.codec),this._encoder=new Te(this,e)}digest(e){if(!(e instanceof AudioData))throw new TypeError("audioData must be an AudioData.");return this._encoder.digest(e)}_flush(){return this._encoder.flush()}},kt=class extends N{_encoder;_accumulatedFrameCount=0;constructor(e){super(e.codec),this._encoder=new Te(this,e)}digest(e){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");let t=e.numberOfChannels,r=e.sampleRate,s=e.length,a=new Float32Array(t*s);for(let o=0;o<t;o++){let u=e.getChannelData(o);a.set(u,o*s)}let n=new AudioData({format:"f32-planar",sampleRate:r,numberOfFrames:s,numberOfChannels:t,timestamp:Math.round(1e6*this._accumulatedFrameCount/r),data:a}),c=this._encoder.digest(n);return n.close(),this._accumulatedFrameCount+=s,c}_flush(){return this._encoder.flush()}},Tt=class extends N{_encoder;_abortController=null;_track;_offsetTimestamps=!0;constructor(e,t){if(!(e instanceof MediaStreamTrack)||e.kind!=="audio")throw new TypeError("track must be an audio MediaStreamTrack.");super(t.codec),this._encoder=new Te(this,t),this._track=e}_start(){this._abortController=new AbortController;let e=new MediaStreamTrackProcessor({track:this._track}),t=new WritableStream({write:r=>{this._encoder.digest(r),r.close()}});e.readable.pipeTo(t,{signal:this._abortController.signal}).catch(r=>{r instanceof DOMException&&r.name==="AbortError"||console.error("Pipe error:",r)})}async _flush(){this._abortController&&(this._abortController.abort(),this._abortController=null),await this._encoder.flush()}},ce=class extends oe{_connectedTrack=null;_codec;constructor(e){if(super(),!Fe.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${Fe.join(", ")}.`);this._codec=e}},xt=class extends ce{_parser;constructor(e){super(e),this._parser=new ve({codec:e,output:(t,r)=>this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack,t,r),error:t=>console.error("Subtitle parse error:",t)})}digest(e){if(typeof e!="string")throw new TypeError("text must be a string.");return this._ensureValidDigest(),this._parser.parse(e),this._connectedTrack.output._muxer.mutex.currentPromise}};var Ct=class{_muxer;_writer;_tracks=[];_started=!1;_finalizing=!1;_mutex=new H;constructor(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof Y))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof G))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,t={}){if(!(e instanceof W))throw new TypeError("source must be a VideoSource.");if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(typeof t.rotation=="number"&&![0,90,180,270].includes(t.rotation))throw new TypeError(`Invalid video rotation: ${t.rotation}. Has to be 0, 90, 180 or 270.`);if(Array.isArray(t.rotation)&&(t.rotation.length!==9||t.rotation.some(r=>!Number.isFinite(r))))throw new TypeError(`Invalid video transformation matrix: ${t.rotation.join()}`);if(t.frameRate!==void 0&&(!Number.isInteger(t.frameRate)||t.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${t.frameRate}. Must be a positive integer.`);this._addTrack("video",e,t)}addAudioTrack(e,t={}){if(!(e instanceof N))throw new TypeError("source must be an AudioSource.");if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");this._addTrack("audio",e,t)}addSubtitleTrack(e,t={}){if(!(e instanceof ce))throw new TypeError("source must be a SubtitleSource.");if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");this._addTrack("subtitle",e,t)}_addTrack(e,t,r){if(this._started)throw new Error("Cannot add track after output has started.");if(t._connectedTrack)throw new Error("Source is already used for a track.");let s={id:this._tracks.length+1,output:this,type:e,source:t,metadata:r};this._muxer.beforeTrackAdd(s),this._tracks.push(s),t._connectedTrack=s}async start(){if(this._started)throw new Error("Output already started.");this._started=!0,this._writer.start();let e=await this._mutex.acquire();await this._muxer.start();for(let t of this._tracks)t.source._start();e()}async finalize(){if(!this._started)throw new Error("Cannot finalize before starting.");if(this._finalizing)throw new Error("Cannot call finalize twice.");this._finalizing=!0;let e=await this._mutex.acquire(),t=this._tracks.map(r=>r.source._flush());await Promise.all(t),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),e()}};var xe=class{_sizePromise=null;_getSize(){return this._sizePromise??=this._retrieveSize()}},St=class extends xe{constructor(t){super();this.buffer=t}async _read(t,r){return new Uint8Array(this.buffer,t,r-t)}async _retrieveSize(){return this.buffer.byteLength}},wt=class extends xe{constructor(t){super();this.blob=t}async _read(t,r){let a=await this.blob.slice(t,r).arrayBuffer();return new Uint8Array(a)}async _retrieveSize(){return this.blob.size}};var ue=class{input;constructor(e){this.input=e}};var Be=class{_backing;constructor(e){this._backing=e}isVideoTrack(){return this instanceof Ce}isAudioTrack(){return this instanceof Se}computeDuration(){return this._backing.computeDuration()}},Ce=class extends Be{_backing;constructor(e){super(e),this._backing=e}getCodec(){return this._backing.getCodec()}getWidth(){return this._backing.getWidth()}getHeight(){return this._backing.getHeight()}getRotation(){return this._backing.getRotation()}async getRotatedWidth(){return await this._backing.getRotation()%180===0?this._backing.getWidth():this._backing.getHeight()}async getRotatedHeight(){return await this._backing.getRotation()%180===0?this._backing.getHeight():this._backing.getWidth()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecMimeType(){return(await this.getDecoderConfig()).codec}},Se=class extends Be{_backing;constructor(e){super(e),this._backing=e}getCodec(){return this._backing.getCodec()}getNumberOfChannels(){return this._backing.getNumberOfChannels()}getSampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecMimeType(){return(await this.getDecoderConfig()).codec}};var me=class{constructor(e,t=1/0){this.source=e;this.maxStorableBytes=t}loadedSegments=[];loadingSegments=[];sourceSizePromise=null;nextAge=0;totalStoredBytes=0;async loadRange(e,t){t=Math.min(t,await this.source._getSize());let r=this.loadingSegments.find(o=>o.start<=e&&o.end>=t);if(r){await r.promise;return}if(this.loadedSegments.some(o=>o.start<=e&&o.end>=t))return;let a=this.source._read(e,t),n={start:e,end:t,promise:a};this.loadingSegments.push(n);let c=await a;Ut(this.loadingSegments,n),this.insertIntoLoadedSegments(e,c)}insertIntoLoadedSegments(e,t){let r={start:e,end:e+t.byteLength,bytes:t,view:new DataView(t.buffer),age:this.nextAge++},s=A(this.loadedSegments,e,a=>a.start);(s===-1||this.loadedSegments[s].start<r.start)&&s++,this.loadedSegments.splice(s,0,r),this.totalStoredBytes+=t.byteLength;for(let a=s+1;a<this.loadedSegments.length;a++){let n=this.loadedSegments[a];if(n.start>=r.end)break;r.start<=n.start&&n.end<=r.end&&(this.loadedSegments.splice(a,1),a--)}for(;this.totalStoredBytes>this.maxStorableBytes&&this.loadedSegments.length>1;){let a=null,n=-1;for(let c=0;c<this.loadedSegments.length;c++){let o=this.loadedSegments[c];(!a||o.age<a.age)&&(a=o,n=c)}l(a),this.totalStoredBytes-=a.bytes.byteLength,this.loadedSegments.splice(n,1)}}getViewAndOffset(e,t){let r=A(this.loadedSegments,e,a=>a.start),s=null;if(r!==-1)for(let a=r;a<this.loadedSegments.length;a++){let n=this.loadedSegments[a];if(n.start>e)break;if(t<=n.end){s=n;break}}if(!s)throw new Error(`No segment loaded for range [${e}, ${t}).`);return s.age=this.nextAge++,{view:s.view,offset:s.bytes.byteOffset+e-s.start}}forgetRange(e,t){if(t<=e)return;let r=A(this.loadedSegments,e,a=>a.start);if(r===-1)return;let s=this.loadedSegments[r];s.start!==e||s.end!==t||(this.loadedSegments.splice(r,1),this.totalStoredBytes-=s.bytes.byteLength)}};var Z=class{constructor(e){this.reader=e}pos=0;readRange(e,t){let{view:r,offset:s}=this.reader.getViewAndOffset(e,t);return new Uint8Array(r.buffer,s,t-e)}readU8(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+1);return this.pos++,e.getUint8(t)}readU16(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+2);return this.pos+=2,e.getUint16(t,!1)}readU24(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+3);this.pos+=3;let r=e.getUint16(t,!1),s=e.getUint8(t+2);return r*256+s}readS32(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getInt32(t,!1)}readU32(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getUint32(t,!1)}readI32(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getInt32(t,!1)}readU64(){let e=this.readU32(),t=this.readU32();return e*4294967296+t}readF64(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+8);return this.pos+=8,e.getFloat64(t,!1)}readFixed_16_16(){return this.readS32()/65536}readFixed_2_30(){return this.readS32()/1073741824}readAscii(e){let{view:t,offset:r}=this.reader.getViewAndOffset(this.pos,this.pos+e);this.pos+=e;let s="";for(let a=0;a<e;a++)s+=String.fromCharCode(t.getUint8(r+a));return s}readIsomVariableInteger(){let e=0;for(let t=0;t<4;t++){e<<=7;let r=this.readU8();if(e|=r&127,!(r&128))break}return e}readBoxHeader(){let e=this.readU32(),t=this.readAscii(4),r=8;return e===1&&(e=this.readU64(),r=16),{name:t,totalSize:e,headerSize:r,contentSize:e-r}}};var Ci=[L(0),L(90),L(180),L(270)],We=class extends ue{isobmffReader;currentTrack=null;tracks=[];metadataPromise=null;movieTimescale=-1;movieDurationInTimescale=-1;isFragmented=!1;fragmentTrackDefaults=[];fragments=[];currentFragment=null;fragmentLookupMutex=new H;chunkReader;constructor(e){super(e),this.isobmffReader=new Z(e._mainReader),this.chunkReader=new Z(new me(e._source,64*2**20))}async computeDuration(){let e=await this.getTracks(),t=await Promise.all(e.map(r=>r.computeDuration()));return Math.max(0,...t)}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();let e="video/mp4";if(this.tracks.length>0){let t=await Promise.all(this.tracks.map(s=>s.inputTrack.getCodecMimeType())),r=[...new Set(t)];e+=`; codecs="${r.join(", ")}"`}return e}readMetadata(){return this.metadataPromise??=(async()=>{let e=await this.isobmffReader.reader.source._getSize();for(;this.isobmffReader.pos<e;){await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+16);let t=this.isobmffReader.pos,r=this.isobmffReader.readBoxHeader();if(r.name==="moov"){await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+r.contentSize),this.readContiguousBoxes(r.contentSize);break}this.isobmffReader.pos=t+r.totalSize}if(this.isFragmented){await this.isobmffReader.reader.loadRange(e-4,e),this.isobmffReader.pos=e-4;let t=this.isobmffReader.readU32(),r=e-t;if(r>=0&&r<e){await this.isobmffReader.reader.loadRange(r,e),this.isobmffReader.pos=r;let s=this.isobmffReader.readBoxHeader();s.name==="mfra"&&this.readContiguousBoxes(s.contentSize)}}})()}getSampleTableForTrack(e){if(e.sampleTable)return e.sampleTable;let t={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:[]};e.sampleTable=t,this.isobmffReader.pos=e.sampleTableOffset,this.currentTrack=e,this.traverseBox(),this.currentTrack=null;for(let r of t.sampleTimingEntries)for(let s=0;s<r.count;s++)t.presentationTimestamps.push({presentationTimestamp:r.startDecodeTimestamp+s*r.delta,sampleIndex:r.startIndex+s});for(let r of t.sampleCompositionTimeOffsets)for(let s=0;s<r.count;s++){let a=r.startIndex+s,n=t.presentationTimestamps[a];n&&(n.presentationTimestamp+=r.offset)}return t.presentationTimestamps.sort((r,s)=>r.presentationTimestamp-s.presentationTimestamp),e.sampleTable}async readFragment(){let e=this.isobmffReader.pos;await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+16);let t=this.isobmffReader.readBoxHeader();l(t.name==="moof"),await this.isobmffReader.reader.loadRange(e,e+t.totalSize),this.isobmffReader.pos=e,this.traverseBox();let r=B(this.fragments,e,a=>a.moofOffset);l(r!==-1);let s=this.fragments[r];l(s.moofOffset===e),this.isobmffReader.reader.forgetRange(e,e+t.totalSize);for(let[a,n]of s.trackData){if(n.startTimestampIsFinal)continue;let c=this.tracks.find(d=>d.id===a);this.isobmffReader.pos=0;let o=null,u=null,m=A(c.fragments,e-1,d=>d.moofOffset);for(m!==-1&&(o=c.fragments[m],u=o,this.isobmffReader.pos=o.moofOffset+o.moofSize);this.isobmffReader.pos<e;){if(o?.nextFragment)o=o.nextFragment,this.isobmffReader.pos=o.moofOffset+o.moofSize;else{await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+16);let d=this.isobmffReader.pos,h=this.isobmffReader.readBoxHeader();if(h.name==="moof"){let g=B(this.fragments,d,b=>b.moofOffset);if(g===-1){this.isobmffReader.pos=d;let b=await this.readFragment();o&&(o.nextFragment=b),o=b}else{let b=this.fragments[g];o&&(o.nextFragment=b),o=b}}this.isobmffReader.pos=d+h.totalSize}o&&o.trackData.has(a)&&(u=o)}if(u){let d=u.trackData.get(a);l(d.startTimestampIsFinal),dr(n,d.endTimestamp)}n.startTimestampIsFinal=!0}return s}readContiguousBoxes(e){let t=this.isobmffReader.pos;for(;this.isobmffReader.pos-t<e;)this.traverseBox()}traverseBox(){let e=this.isobmffReader.pos,t=this.isobmffReader.readBoxHeader(),r=e+t.totalSize;switch(t.name){case"mdia":case"minf":case"dinf":case"mfra":this.readContiguousBoxes(t.contentSize);break;case"mvhd":{let s=this.isobmffReader.readU8();this.isobmffReader.pos+=3,s===1?(this.isobmffReader.pos+=16,this.movieTimescale=this.isobmffReader.readU32(),this.movieDurationInTimescale=this.isobmffReader.readU64()):(this.isobmffReader.pos+=8,this.movieTimescale=this.isobmffReader.readU32(),this.movieDurationInTimescale=this.isobmffReader.readU32())}break;case"trak":{let s={id:-1,demuxer:this,inputTrack:null,info:null,timescale:-1,durationInTimescale:-1,rotation:0,sampleTableOffset:-1,sampleTable:null,fragmentLookupTable:null,currentFragmentState:null,fragments:[]};if(this.currentTrack=s,this.readContiguousBoxes(t.contentSize),s.id!==-1&&s.timescale!==-1&&s.info!==null){if(s.info.type==="video"&&s.info.codec!==null){let a=s;s.inputTrack=new Ce(new yt(a)),this.tracks.push(s)}else if(s.info.type==="audio"&&s.info.codec!==null){let a=s;if(s.inputTrack=new Se(new vt(a)),this.tracks.push(s),s.info.codec==="aac"){let n=ot(s.info.codecDescription);n.numberOfChannels!==null&&(s.info.numberOfChannels=n.numberOfChannels),n.sampleRate!==null&&(s.info.sampleRate=n.sampleRate)}}}this.currentTrack=null}break;case"tkhd":{let s=this.currentTrack;l(s);let a=this.isobmffReader.readU8();if(!((this.isobmffReader.readU24()&1)!==0))break;if(a===0)this.isobmffReader.pos+=8,s.id=this.isobmffReader.readU32(),this.isobmffReader.pos+=8;else if(a===1)this.isobmffReader.pos+=16,s.id=this.isobmffReader.readU32(),this.isobmffReader.pos+=12;else throw new Error(`Incorrect track header version ${a}.`);this.isobmffReader.pos+=2*4+2+2+2+2;let o=[];o.push(this.isobmffReader.readFixed_16_16(),this.isobmffReader.readFixed_16_16()),this.isobmffReader.pos+=4,o.push(this.isobmffReader.readFixed_16_16(),this.isobmffReader.readFixed_16_16());let u=Ci.findIndex(m=>m.every((d,h)=>d===o[h]));u===-1?s.rotation=0:s.rotation=90*u}break;case"mdhd":{let s=this.currentTrack;l(s);let a=this.isobmffReader.readU8();this.isobmffReader.pos+=3,a===0?(this.isobmffReader.pos+=8,s.timescale=this.isobmffReader.readU32(),s.durationInTimescale=this.isobmffReader.readU32()):a===1&&(this.isobmffReader.pos+=16,s.timescale=this.isobmffReader.readU32(),s.durationInTimescale=this.isobmffReader.readU64())}break;case"hdlr":{let s=this.currentTrack;l(s),this.isobmffReader.pos+=8;let a=this.isobmffReader.readAscii(4);a==="vide"?s.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null}:a==="soun"&&(s.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null})}break;case"stbl":{let s=this.currentTrack;l(s),s.sampleTableOffset=e,this.readContiguousBoxes(t.contentSize)}break;case"stsd":{let s=this.currentTrack;if(l(s),s.info===null||s.sampleTable)break;let a=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let n=this.isobmffReader.readU32();for(let c=0;c<n;c++){let o=this.isobmffReader.readBoxHeader();if(s.info.type==="video"){if(o.name==="avc1")s.info.codec="avc";else if(o.name==="hvc1"||o.name==="hev1")s.info.codec="hevc";else{console.warn(`Unsupported video sample entry type ${o.name}.`);break}this.isobmffReader.pos+=6*1+2+2+2+3*4,s.info.width=this.isobmffReader.readU16(),s.info.height=this.isobmffReader.readU16(),this.isobmffReader.pos+=50,this.readContiguousBoxes(e+o.totalSize-this.isobmffReader.pos)}else{if(o.name==="mp4a")s.info.codec="aac";else if(o.name.toLowerCase()==="opus")s.info.codec="opus";else{console.warn(`Unsupported audio sample entry type ${o.name}.`);break}this.isobmffReader.pos+=6*1+2;let u=this.isobmffReader.readU16();this.isobmffReader.pos+=3*2;let m=this.isobmffReader.readU16();this.isobmffReader.pos+=6;let d=this.isobmffReader.readU32()/65536;if(a===0&&u>0){if(u===1)this.isobmffReader.pos+=4*4;else if(u===2){this.isobmffReader.pos+=4,d=this.isobmffReader.readF64(),m=this.isobmffReader.readU32(),this.isobmffReader.pos+=4;let h=this.isobmffReader.readU32(),g=this.isobmffReader.readU32(),b=this.isobmffReader.readU32(),f=this.isobmffReader.readU32()}}s.info.numberOfChannels=m,s.info.sampleRate=d,this.readContiguousBoxes(e+o.totalSize-this.isobmffReader.pos)}}}break;case"avcC":{let s=this.currentTrack;l(s&&s.info),s.info.codecDescription=this.isobmffReader.readRange(this.isobmffReader.pos,this.isobmffReader.pos+t.contentSize)}break;case"hvcC":{let s=this.currentTrack;l(s&&s.info),s.info.codecDescription=this.isobmffReader.readRange(this.isobmffReader.pos,this.isobmffReader.pos+t.contentSize)}break;case"colr":{let s=this.currentTrack;if(l(s&&s.info?.type==="video"),this.isobmffReader.readAscii(4)!=="nclx")break;let n=this.isobmffReader.readU16(),c=this.isobmffReader.readU16(),o=this.isobmffReader.readU16(),u=!!(this.isobmffReader.readU8()&128);s.info.colorSpace={primaries:Mt[n],transfer:Vt[c],matrix:Dt[o],fullRange:u}}break;case"wave":t.totalSize>8&&this.readContiguousBoxes(t.contentSize);break;case"esds":{let s=this.currentTrack;l(s&&s.info),this.isobmffReader.pos+=4;let a=this.isobmffReader.readU8();l(a===3),this.isobmffReader.readIsomVariableInteger(),this.isobmffReader.pos+=2;let n=this.isobmffReader.readU8(),c=(n&128)!==0,o=(n&64)!==0,u=(n&32)!==0;if(c&&(this.isobmffReader.pos+=2),o){let b=this.isobmffReader.readU8();this.isobmffReader.pos+=b}u&&(this.isobmffReader.pos+=2);let m=this.isobmffReader.readU8();l(m===4),this.isobmffReader.readIsomVariableInteger();let d=this.isobmffReader.readU8();l(d===64),this.isobmffReader.pos+=12;let h=this.isobmffReader.readU8();l(h===5);let g=this.isobmffReader.readIsomVariableInteger();s.info.codecDescription=this.isobmffReader.readRange(this.isobmffReader.pos,this.isobmffReader.pos+g)}break;case"stts":{let s=this.currentTrack;if(l(s),!s.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32(),n=0,c=0;for(let o=0;o<a;o++){let u=this.isobmffReader.readU32(),m=this.isobmffReader.readU32();s.sampleTable.sampleTimingEntries.push({startIndex:n,startDecodeTimestamp:c,count:u,delta:m}),n+=u,c+=u*m}}break;case"ctts":{let s=this.currentTrack;if(l(s),!s.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32(),n=0;for(let c=0;c<a;c++){let o=this.isobmffReader.readU32(),u=this.isobmffReader.readI32();s.sampleTable.sampleCompositionTimeOffsets.push({startIndex:n,count:o,offset:u}),n+=o}}break;case"stsz":{let s=this.currentTrack;if(l(s),!s.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32(),n=this.isobmffReader.readU32();if(a===0)for(let c=0;c<n;c++){let o=this.isobmffReader.readU32();s.sampleTable.sampleSizes.push(o)}else s.sampleTable.sampleSizes.push(a)}break;case"stz2":throw new Error("Unsupported.");case"stss":{let s=this.currentTrack;if(l(s),!s.sampleTable)break;this.isobmffReader.pos+=4,s.sampleTable.keySampleIndices=[];let a=this.isobmffReader.readU32();for(let n=0;n<a;n++){let c=this.isobmffReader.readU32()-1;s.sampleTable.keySampleIndices.push(c)}}break;case"stsc":{let s=this.currentTrack;if(l(s),!s.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32();for(let c=0;c<a;c++){let o=this.isobmffReader.readU32()-1,u=this.isobmffReader.readU32(),m=this.isobmffReader.readU32();s.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:o,samplesPerChunk:u,sampleDescriptionIndex:m})}let n=0;for(let c=0;c<s.sampleTable.sampleToChunk.length;c++)if(s.sampleTable.sampleToChunk[c].startSampleIndex=n,c<s.sampleTable.sampleToChunk.length-1){let u=s.sampleTable.sampleToChunk[c+1].startChunkIndex-s.sampleTable.sampleToChunk[c].startChunkIndex;n+=u*s.sampleTable.sampleToChunk[c].samplesPerChunk}}break;case"stco":{let s=this.currentTrack;if(l(s),!s.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32();for(let n=0;n<a;n++){let c=this.isobmffReader.readU32();s.sampleTable.chunkOffsets.push(c)}}break;case"co64":{let s=this.currentTrack;if(l(s),!s.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32();for(let n=0;n<a;n++){let c=this.isobmffReader.readU64();s.sampleTable.chunkOffsets.push(c)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(t.contentSize);break;case"mehd":{let s=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let a=s===1?this.isobmffReader.readU64():this.isobmffReader.readU32();this.movieDurationInTimescale=a}break;case"trex":{this.isobmffReader.pos+=4;let s=this.isobmffReader.readU32(),a=this.isobmffReader.readU32(),n=this.isobmffReader.readU32(),c=this.isobmffReader.readU32(),o=this.isobmffReader.readU32();this.fragmentTrackDefaults.push({trackId:s,defaultSampleDescriptionIndex:a,defaultSampleDuration:n,defaultSampleSize:c,defaultSampleFlags:o})}break;case"tfra":{let s=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let a=this.isobmffReader.readU32(),n=this.tracks.find(C=>C.id===a);if(!n)break;n.fragmentLookupTable=[];let c=this.isobmffReader.readU32(),o=(c&48)>>4,u=(c&12)>>2,m=c&3,d=this.isobmffReader,h=[d.readU8.bind(d),d.readU16.bind(d),d.readU24.bind(d),d.readU32.bind(d)],g=h[o],b=h[u],f=h[m],k=this.isobmffReader.readU32();for(let C=0;C<k;C++){let v=s===1?this.isobmffReader.readU64():this.isobmffReader.readU32(),w=s===1?this.isobmffReader.readU64():this.isobmffReader.readU32(),O=g(),R=b(),V=f();n.fragmentLookupTable.push({timestamp:v,moofOffset:w})}}break;case"moof":{this.currentFragment={moofOffset:e,moofSize:t.totalSize,implicitBaseDataOffset:e,trackData:new Map,dataStart:1/0,dataEnd:0,nextFragment:null},this.readContiguousBoxes(t.contentSize);let s=A(this.fragments,this.currentFragment.moofOffset,a=>a.moofOffset);this.fragments.splice(s+1,0,this.currentFragment);for(let[,a]of this.currentFragment.trackData){let n=a.samples[0],c=_(a.samples);this.currentFragment.dataStart=Math.min(this.currentFragment.dataStart,n.byteOffset),this.currentFragment.dataEnd=Math.max(this.currentFragment.dataEnd,c.byteOffset+c.byteSize)}this.currentFragment=null}break;case"traf":if(l(this.currentFragment),this.readContiguousBoxes(t.contentSize),this.currentTrack){let s=this.currentFragment.trackData.get(this.currentTrack.id);if(s){let a=A(this.currentTrack.fragments,this.currentFragment.moofOffset,c=>c.moofOffset);this.currentTrack.fragments.splice(a+1,0,this.currentFragment);let{currentFragmentState:n}=this.currentTrack;l(n),n.startTimestamp!==null&&(dr(s,n.startTimestamp),s.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{l(this.currentFragment),this.isobmffReader.pos+=1;let s=this.isobmffReader.readU24(),a=!!(s&1),n=!!(s&2),c=!!(s&8),o=!!(s&16),u=!!(s&32),m=!!(s&65536),d=!!(s&131072),h=this.isobmffReader.readU32(),g=this.tracks.find(f=>f.id===h);if(!g)break;let b=this.fragmentTrackDefaults.find(f=>f.trackId===h);this.currentTrack=g,g.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:b?.defaultSampleDescriptionIndex??null,defaultSampleDuration:b?.defaultSampleDuration??null,defaultSampleSize:b?.defaultSampleSize??null,defaultSampleFlags:b?.defaultSampleFlags??null,startTimestamp:null},a?g.currentFragmentState.baseDataOffset=this.isobmffReader.readU64():d&&(g.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),n&&(g.currentFragmentState.sampleDescriptionIndex=this.isobmffReader.readU32()),c&&(g.currentFragmentState.defaultSampleDuration=this.isobmffReader.readU32()),o&&(g.currentFragmentState.defaultSampleSize=this.isobmffReader.readU32()),u&&(g.currentFragmentState.defaultSampleFlags=this.isobmffReader.readU32()),m&&(g.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{let s=this.currentTrack;if(!s)break;l(s.currentFragmentState);let a=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let n=a===0?this.isobmffReader.readU32():this.isobmffReader.readU64();s.currentFragmentState.startTimestamp=n}break;case"trun":{let s=this.currentTrack;if(!s)break;if(l(this.currentFragment),l(s.currentFragmentState),this.currentFragment.trackData.has(s.id))throw new Error("Can't have two trun boxes for the same track in one fragment.");let a=this.isobmffReader.readU8(),n=this.isobmffReader.readU24(),c=!!(n&1),o=!!(n&4),u=!!(n&256),m=!!(n&512),d=!!(n&1024),h=!!(n&2048),g=this.isobmffReader.readU32(),b=s.currentFragmentState.baseDataOffset;c&&(b+=this.isobmffReader.readI32());let f=null;o&&(f=this.isobmffReader.readU32());let k=b;if(g===0){this.currentFragment.implicitBaseDataOffset=k;break}let C=0,v={startTimestamp:0,endTimestamp:0,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(s.id,v);for(let R=0;R<g;R++){let V;u?V=this.isobmffReader.readU32():(l(s.currentFragmentState.defaultSampleDuration!==null),V=s.currentFragmentState.defaultSampleDuration);let J;m?J=this.isobmffReader.readU32():(l(s.currentFragmentState.defaultSampleSize!==null),J=s.currentFragmentState.defaultSampleSize);let we;d?we=this.isobmffReader.readU32():(l(s.currentFragmentState.defaultSampleFlags!==null),we=s.currentFragmentState.defaultSampleFlags),R===0&&f!==null&&(we=f);let Ye=0;h&&(a===0?Ye=this.isobmffReader.readU32():Ye=this.isobmffReader.readI32());let pr=!(we&65536);v.samples.push({presentationTimestamp:C+Ye,duration:V,byteOffset:k,byteSize:J,isKeyFrame:pr}),k+=J,C+=V}v.presentationTimestamps=v.samples.map((R,V)=>({presentationTimestamp:R.presentationTimestamp,sampleIndex:V})).sort((R,V)=>R.presentationTimestamp-V.presentationTimestamp);let w=v.samples[v.presentationTimestamps[0].sampleIndex],O=v.samples[_(v.presentationTimestamps).sampleIndex];v.startTimestamp=w.presentationTimestamp,v.endTimestamp=O.presentationTimestamp+O.duration,this.currentFragment.implicitBaseDataOffset=k}break}this.isobmffReader.pos=r}},Ne=class{constructor(e){this.internalTrack=e}chunkToSampleIndex=new WeakMap;chunkToFragmentLocation=new WeakMap;getCodec(){throw new Error("Not implemented on base class.")}async computeDuration(){let t=(await this.getChunk(1/0,{metadataOnly:!0}))?.timestamp;return t?t/1e6:0}async getFirstChunk(e){return this.internalTrack.demuxer.isFragmented?this.performFragmentedLookup(()=>{let t=this.internalTrack.fragments[0];return{fragmentIndex:t?0:-1,sampleIndex:t?0:-1,correctSampleFound:!!t}},0,1/0,e):this.fetchChunkForSampleIndex(0,e)}roundToMicrosecond(e){return(Math.floor(e*1e6)+.99999999)/1e6}async getChunk(e,t){e=this.roundToMicrosecond(e);let r=e*this.internalTrack.timescale;if(this.internalTrack.demuxer.isFragmented)return this.performFragmentedLookup(()=>this.findSampleInFragmentsForTimestamp(r),r,r,t);{let s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),a=lr(s,r);return this.fetchChunkForSampleIndex(a,t)}}async getNextChunk(e,t){if(this.internalTrack.demuxer.isFragmented){let s=this.chunkToFragmentLocation.get(e);if(s===void 0)throw new Error("Chunk was not created from this track.");let a=s.fragment.trackData.get(this.internalTrack.id),n=a.samples[s.sampleIndex],c=B(this.internalTrack.fragments,s.fragment.moofOffset,o=>o.moofOffset);return l(c!==-1),this.performFragmentedLookup(()=>{if(s.sampleIndex+1<a.samples.length)return{fragmentIndex:c,sampleIndex:s.sampleIndex+1,correctSampleFound:!0};{let o=s.fragment;for(;o.nextFragment;)if(o=o.nextFragment,o.trackData.get(this.internalTrack.id)){let m=B(this.internalTrack.fragments,o.moofOffset,d=>d.moofOffset);return l(m!==-1),{fragmentIndex:m,sampleIndex:0,correctSampleFound:!0}}return{fragmentIndex:c,sampleIndex:-1,correctSampleFound:!1}}},n.presentationTimestamp,1/0,t)}let r=this.chunkToSampleIndex.get(e);if(r===void 0)throw new Error("Chunk was not created from this track.");return this.fetchChunkForSampleIndex(r+1,t)}async getKeyChunk(e,t){e=this.roundToMicrosecond(e);let r=e*this.internalTrack.timescale;if(this.internalTrack.demuxer.isFragmented)return this.performFragmentedLookup(()=>this.findKeySampleInFragmentsForTimestamp(r),r,r,t);let s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),a=lr(s,r),n=a===-1?-1:wi(s,a);return this.fetchChunkForSampleIndex(n,t)}async getNextKeyChunk(e,t){if(this.internalTrack.demuxer.isFragmented){let n=this.chunkToFragmentLocation.get(e);if(n===void 0)throw new Error("Chunk was not created from this track.");let c=n.fragment.trackData.get(this.internalTrack.id),o=c.samples[n.sampleIndex],u=B(this.internalTrack.fragments,n.fragment.moofOffset,m=>m.moofOffset);return l(u!==-1),this.performFragmentedLookup(()=>{let m=c.samples.findIndex((d,h)=>d.isKeyFrame&&h>n.sampleIndex);if(m!==-1)return{fragmentIndex:u,sampleIndex:m,correctSampleFound:!0};{let d=n.fragment;for(;d.nextFragment;){d=d.nextFragment;let h=d.trackData.get(this.internalTrack.id);if(h){let g=B(this.internalTrack.fragments,d.moofOffset,f=>f.moofOffset);l(g!==-1);let b=h.samples.findIndex(f=>f.isKeyFrame);if(b===-1)throw new Error("Not supported: Fragment does not contain key sample.");return{fragmentIndex:g,sampleIndex:b,correctSampleFound:!0}}}return{fragmentIndex:u,sampleIndex:-1,correctSampleFound:!1}}},o.presentationTimestamp,1/0,t)}let r=this.chunkToSampleIndex.get(e);if(r===void 0)throw new Error("Chunk was not created from this track.");let s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),a=yi(s,r);return this.fetchChunkForSampleIndex(a,t)}async fetchChunkForSampleIndex(e,t){if(e===-1)return null;let r=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=Si(r,e);if(!s)return null;let a;t.metadataOnly?a=new Uint8Array(0):(await this.internalTrack.demuxer.chunkReader.reader.loadRange(s.chunkOffset,s.chunkOffset+s.chunkSize),a=this.internalTrack.demuxer.chunkReader.readRange(s.sampleOffset,s.sampleOffset+s.sampleSize));let n=1e6*s.presentationTimestamp/this.internalTrack.timescale,c=1e6*s.duration/this.internalTrack.timescale,o=this.createChunk(a,n,c,s.isKeyFrame);return this.chunkToSampleIndex.set(o,e),o}async fetchChunkInFragment(e,t,r){if(t===-1)return null;let a=e.trackData.get(this.internalTrack.id).samples[t];l(a);let n;r.metadataOnly?n=new Uint8Array(0):(await this.internalTrack.demuxer.chunkReader.reader.loadRange(e.dataStart,e.dataEnd),n=this.internalTrack.demuxer.chunkReader.readRange(a.byteOffset,a.byteOffset+a.byteSize));let c=1e6*a.presentationTimestamp/this.internalTrack.timescale,o=1e6*a.duration/this.internalTrack.timescale,u=this.createChunk(n,c,o,a.isKeyFrame);return this.chunkToFragmentLocation.set(u,{fragment:e,sampleIndex:t}),u}findSampleInFragmentsForTimestamp(e){let t=A(this.internalTrack.fragments,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp),r=-1,s=!1;if(t!==-1){let n=this.internalTrack.fragments[t].trackData.get(this.internalTrack.id),c=A(n.presentationTimestamps,e,o=>o.presentationTimestamp);l(c!==-1),r=n.presentationTimestamps[c].sampleIndex,s=e<n.endTimestamp}return{fragmentIndex:t,sampleIndex:r,correctSampleFound:s}}findKeySampleInFragmentsForTimestamp(e){let t=A(this.internalTrack.fragments,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp),r=-1,s=!1;if(t!==-1){let n=this.internalTrack.fragments[t].trackData.get(this.internalTrack.id),c=n.presentationTimestamps.findLastIndex(u=>n.samples[u.sampleIndex].isKeyFrame&&u.presentationTimestamp<=e);if(c===-1)throw new Error("Not supported: Fragment does not begin with a key sample.");r=n.presentationTimestamps[c].sampleIndex,s=e<n.endTimestamp}return{fragmentIndex:t,sampleIndex:r,correctSampleFound:s}}async performFragmentedLookup(e,t,r,s){let a=this.internalTrack.demuxer,n=await a.fragmentLookupMutex.acquire();try{let{fragmentIndex:c,sampleIndex:o,correctSampleFound:u}=e();if(u){let k=this.internalTrack.fragments[c];return this.fetchChunkInFragment(k,o,s)}let m=a.isobmffReader,d=await m.reader.source._getSize(),h=null,g=c,b=o,f=null;if(this.internalTrack.fragmentLookupTable){let k=A(this.internalTrack.fragmentLookupTable,t,C=>C.timestamp);k!==-1&&(f=this.internalTrack.fragmentLookupTable[k])}if(c===-1)m.pos=f?.moofOffset??0;else{let k=this.internalTrack.fragments[c];!f||k.moofOffset>=k.moofOffset?(m.pos=k.moofOffset+k.moofSize,h=k):m.pos=f.moofOffset}for(;m.pos<d;){if(h){let v=h.trackData.get(this.internalTrack.id);if(v&&v.startTimestamp>r)break;if(h.nextFragment){m.pos=h.nextFragment.moofOffset+h.nextFragment.moofSize,h=h.nextFragment;continue}}await m.reader.loadRange(m.pos,m.pos+16);let k=m.pos,C=m.readBoxHeader();if(C.name==="moof"){let v=B(a.fragments,k,w=>w.moofOffset);if(v===-1){m.pos=k;let w=await a.readFragment();h&&(h.nextFragment=w),h=w;let{fragmentIndex:O,sampleIndex:R,correctSampleFound:V}=e();if(V){let J=this.internalTrack.fragments[O];return this.fetchChunkInFragment(J,R,s)}O!==-1&&(g=O,b=R)}else{let w=a.fragments[v];h&&(h.nextFragment=w),h=w}}m.pos=k+C.totalSize}if(g!==-1){let k=this.internalTrack.fragments[g];return this.fetchChunkInFragment(k,b,s)}return null}finally{n()}}},yt=class extends Ne{internalTrack;constructor(e){super(e),this.internalTrack=e}async getCodec(){return this.internalTrack.info.codec}async getWidth(){return this.internalTrack.info.width}async getHeight(){return this.internalTrack.info.height}async getRotation(){return this.internalTrack.rotation}async getDecoderConfig(){return{codec:rr(this.internalTrack.info.codec,this.internalTrack.info.codecDescription),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}}createChunk(e,t,r,s){return new EncodedVideoChunk({data:e,timestamp:t,duration:r,type:s?"key":"delta"})}},vt=class extends Ne{internalTrack;constructor(e){super(e),this.internalTrack=e}async getCodec(){return this.internalTrack.info.codec}async getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}async getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return{codec:sr(this.internalTrack.info.codec,this.internalTrack.info.codecDescription),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}}createChunk(e,t,r,s){return new EncodedAudioChunk({data:e,timestamp:t,duration:r,type:s?"key":"delta"})}},lr=(i,e)=>{let t=A(i.presentationTimestamps,e,r=>r.presentationTimestamp);return t===-1?-1:i.presentationTimestamps[t].sampleIndex},Si=(i,e)=>{let t=A(i.sampleTimingEntries,e,f=>f.startIndex),r=i.sampleTimingEntries[t];if(!r||r.startIndex+r.count<=e)return null;let a=r.startDecodeTimestamp+(e-r.startIndex)*r.delta,n=A(i.sampleCompositionTimeOffsets,e,f=>f.startIndex),c=i.sampleCompositionTimeOffsets[n];c&&(a+=c.offset);let o=i.sampleSizes[Math.min(e,i.sampleSizes.length-1)],u=A(i.sampleToChunk,e,f=>f.startSampleIndex),m=i.sampleToChunk[u];l(m);let d=m.startChunkIndex+Math.floor((e-m.startSampleIndex)/m.samplesPerChunk),h=i.chunkOffsets[d],g=0,b=h;if(i.sampleSizes.length===1)b+=o*(e-m.startSampleIndex),g+=o*m.samplesPerChunk;else{let f=m.startSampleIndex+(d-m.startChunkIndex)*m.samplesPerChunk;for(let k=f;k<f+m.samplesPerChunk;k++){let C=i.sampleSizes[k];k<e&&(b+=C),g+=C}}return{presentationTimestamp:a,duration:r.delta,sampleOffset:b,sampleSize:o,chunkOffset:h,chunkSize:g,isKeyFrame:i.keySampleIndices?B(i.keySampleIndices,e,f=>f)!==-1:!0}},wi=(i,e)=>{if(!i.keySampleIndices)return e;let t=A(i.keySampleIndices,e,r=>r);return i.keySampleIndices[t]??-1},yi=(i,e)=>{if(!i.keySampleIndices)return e+1;let t=A(i.keySampleIndices,e,r=>r);return i.keySampleIndices[t+1]??-1},dr=(i,e)=>{i.startTimestamp+=e,i.endTimestamp+=e;for(let t of i.samples)t.presentationTimestamp+=e;for(let t of i.presentationTimestamps)t.presentationTimestamp+=e};var He=class extends ue{};var Le=class{},It=class extends Le{async _canReadInput(e){if(await e._mainReader.source._getSize()<8)return!1;let r=new Z(e._mainReader);return r.pos=4,r.readAscii(4)==="ftyp"}_createDemuxer(e){return new We(e)}},At=class extends Le{async _canReadInput(){return!1}_createDemuxer(e){return new He(e)}},Qe=new It,vi=Qe,Ii=Qe,Rt=new At,fr=Rt,Ai=Rt,Ri=[Qe,fr];var Ot=class{_source;_formats;_mainReader;_demuxerPromise=null;_format=null;constructor(e){this._formats=e.formats,this._source=e.source,this._mainReader=new me(e.source)}_getDemuxer(){return this._demuxerPromise??=(async()=>{await this._mainReader.loadRange(0,4096);for(let e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unrecognizable format.")})()}async getFormat(){return await this._getDemuxer(),l(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(t=>t.isVideoTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(t=>t.isVideoTrack())??null}async getAudioTracks(){return(await this.getTracks()).filter(t=>t.isAudioTrack())}async getPrimaryAudioTrack(){return(await this.getTracks()).find(t=>t.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}};var Ke=class{async*chunks(e,t=1/0){let r=[],{promise:s,resolve:a}=F(),{promise:n,resolve:c}=F(),o=!1,u=[],m=()=>Math.max(2,u.length);(async()=>{let d=e??await this.getFirstChunk();for(;d&&!o&&!(d.timestamp/1e6>=t);){if(r.length>m()){({promise:n,resolve:c}=F()),await n;continue}r.push(d),a(),{promise:s,resolve:a}=F(),d=await this.getNextChunk(d)}o=!0,a()})();try{for(;;)if(r.length>0){yield r.shift();let d=performance.now();for(u.push(d);u.length>0&&d-u[0]>=1e3;)u.shift();c()}else if(!o)await s;else break}finally{o=!0,c()}}},$e=class{duplicateFrame(e){return structuredClone(e)}async*mediaFramesAtTimestamps(e){let t=Bt(e),r=[],s=[],{promise:a,resolve:n}=F(),{promise:c,resolve:o}=F(),u=!1,m=!1,d=8,h=null,g=f=>{s.push(f),n(),{promise:a,resolve:n}=F()},b=await this.createDecoder(f=>{if(o(),m){f.close();return}let k=!1;for(;r.length>0&&r[0]===f.timestamp;)g(this.duplicateFrame(f)),r.shift(),k=!0;k?(h?.close(),h=f):f.close()});(async()=>{let f=this.createChunkDrain(),k=null,C=null;for await(let v of t){for(;s.length+b.decodeQueueSize>d;)({promise:c,resolve:o}=F()),await c;if(m)break;let w=await f.getChunk(v);if(!w){g(null);continue}let O=await f.getKeyChunk(v);if(!O){g(null);continue}for(r.push(w.timestamp),k&&O.timestamp===k.timestamp&&w.timestamp>=C.timestamp?(l(C),w.timestamp===C.timestamp&&r.length===1&&(h&&g(this.duplicateFrame(h)),r.shift())):(k=O,C=O,b.decode(O));C.timestamp!==w.timestamp;){let R=await f.getNextChunk(C);l(R),C=R,b.decode(R)}b.decodeQueueSize>=10&&await new Promise(R=>b.addEventListener("dequeue",R,{once:!0}))}await b.flush(),b.close(),u=!0,n()})();try{for(;;)if(s.length>0){let f=s.shift();l(f!==void 0),yield f,o()}else if(!u)await a;else break}finally{m=!0,o();for(let f of s)f?.close();h?.close()}}async*mediaFramesInRange(e=0,t=1/0){let r=[],s=!1,a=null,{promise:n,resolve:c}=F(),{promise:o,resolve:u}=F(),m=!1,d=!1,h=8,g=await this.createDecoder(k=>{u();let C=k.timestamp/1e6;if(C>=t&&(d=!0),d){k.close();return}a&&(C>e?(r.push(a),s=!0):a.close()),C>=e&&(r.push(k),s=!0),a=s?null:k,r.length>0&&(c(),{promise:n,resolve:c}=F())}),b=this.createChunkDrain(),f=await b.getKeyChunk(e)??await b.getFirstChunk();if(f){(async()=>{let k=f,C=1/0;if(t<1/0){let w=await b.getChunk(t),O=w?w.type==="key"&&w.timestamp/1e6===t?w:await b.getNextKeyChunk(w):null;O&&(C=O.timestamp/1e6)}let v=b.chunks(f,C);for(await v.next();k&&!d;){if(r.length+g.decodeQueueSize>h){({promise:o,resolve:u}=F()),await o;continue}g.decode(k);let w=await v.next();if(w.done)break;k=w.value}await v.return(),await g.flush(),g.close(),!s&&a&&r.push(a),m=!0,c()})();try{for(;;)if(r.length>0)yield r.shift(),u();else if(!m)await n;else break}finally{d=!0,u();for(let k of r)k.close()}}}},je=class extends Ke{constructor(t){super();this.videoTrack=t}getFirstChunk(t={}){return this.videoTrack._backing.getFirstChunk(t)}getChunk(t,r={}){return this.videoTrack._backing.getChunk(t,r)}getNextChunk(t,r={}){return this.videoTrack._backing.getNextChunk(t,r)}getKeyChunk(t,r={}){return this.videoTrack._backing.getKeyChunk(t,r)}getNextKeyChunk(t,r={}){return this.videoTrack._backing.getNextKeyChunk(t,r)}},qe=class extends $e{constructor(t){super();this.videoTrack=t}decoderConfig=null;async createDecoder(t){this.decoderConfig??=await this.videoTrack.getDecoderConfig();let r=new VideoDecoder({output:t,error:s=>console.error(s)});return r.configure(this.decoderConfig),r}createChunkDrain(){return new je(this.videoTrack)}async getFrame(t){for await(let r of this.mediaFramesAtTimestamps([t]))return r;throw new Error("Internal error: Iterator returned nothing.")}frames(t=0,r=1/0){return this.mediaFramesInRange(t,r)}framesAtTimestamps(t){return this.mediaFramesAtTimestamps(t)}},_t=class{constructor(e,t){this.videoTrack=e;this.dimensions=t;this.videoFrameDrain=new qe(e)}videoFrameDrain;async videoFrameToWrappedCanvas(e){let t=this.dimensions?.width??await this.videoTrack.getRotatedWidth(),r=this.dimensions?.height??await this.videoTrack.getRotatedHeight(),s=await this.videoTrack.getRotation(),a=document.createElement("canvas");a.width=t,a.height=r;let n=a.getContext("2d",{alpha:!1});l(n),n.translate(t/2,r/2),n.rotate(s*Math.PI/180),n.translate(-t/2,-r/2);let[c,o]=s%180===0?[t,r]:[r,t];n.drawImage(e,(t-c)/2,(r-o)/2,c,o);let u={canvas:a,timestamp:e.timestamp/1e6,duration:(e.duration??0)/1e6};return e.close(),u}async getCanvas(e){let t=await this.videoFrameDrain.getFrame(e);return t&&this.videoFrameToWrappedCanvas(t)}async*canvases(e=0,t=1/0){for await(let r of this.videoFrameDrain.frames(e,t))yield this.videoFrameToWrappedCanvas(r)}async*canvasesAtTimestamps(e){for await(let t of this.videoFrameDrain.framesAtTimestamps(e))yield t&&this.videoFrameToWrappedCanvas(t)}},Xe=class extends Ke{constructor(t){super();this.audioTrack=t}getFirstChunk(t={}){return this.audioTrack._backing.getFirstChunk(t)}getChunk(t,r={}){return this.audioTrack._backing.getChunk(t,r)}getNextChunk(t,r={}){return this.audioTrack._backing.getNextChunk(t,r)}getKeyChunk(t,r={}){return this.audioTrack._backing.getKeyChunk(t,r)}getNextKeyChunk(t,r={}){return this.audioTrack._backing.getNextKeyChunk(t,r)}},Ge=class extends $e{constructor(t){super();this.audioTrack=t}decoderConfig=null;async createDecoder(t){this.decoderConfig??=await this.audioTrack.getDecoderConfig();let r=new AudioDecoder({output:t,error:s=>console.error(s)});return r.configure(this.decoderConfig),r}createChunkDrain(){return new Xe(this.audioTrack)}async getData(t){for await(let r of this.mediaFramesAtTimestamps([t]))return r;throw new Error("Internal error: Iterator returned nothing.")}data(t=0,r=1/0){return this.mediaFramesInRange(t,r)}dataAtTimestamps(t){return this.mediaFramesAtTimestamps(t)}},Et=class{constructor(e){this.audioTrack=e;this.audioDataDrain=new Ge(e)}audioDataDrain;audioDataToWrappedArrayBuffer(e){let t=new AudioBuffer({numberOfChannels:e.numberOfChannels,length:e.numberOfFrames,sampleRate:e.sampleRate}),r=new Float32Array(e.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let n=0;n<e.numberOfChannels;n++)e.copyTo(r,{planeIndex:n,format:"f32-planar"}),t.copyToChannel(r,n);let s=1/e.sampleRate,a={buffer:t,timestamp:Math.round(e.timestamp/1e6/s)*s};return e.close(),a}async getBuffer(e){let t=await this.audioDataDrain.getData(e);return t&&this.audioDataToWrappedArrayBuffer(t)}async*buffers(e=0,t=1/0){for await(let r of this.audioDataDrain.data(e,t))yield this.audioDataToWrappedArrayBuffer(r)}async*buffersAtTimestamps(e){for await(let t of this.audioDataDrain.dataAtTimestamps(e))yield t&&this.audioDataToWrappedArrayBuffer(t)}};export{Ri as ALL_FORMATS,se as AUDIO_CODECS,St as ArrayBufferSource,he as ArrayBufferTarget,Et as AudioBufferDrain,kt as AudioBufferSource,Ge as AudioDataDrain,gt as AudioDataSource,N as AudioSource,wt as BlobSource,_t as CanvasDrain,pt as CanvasSource,Xe as EncodedAudioChunkDrain,bt as EncodedAudioChunkSource,je as EncodedVideoChunkDrain,dt as EncodedVideoChunkSource,Qe as ISOBMFF,Ot as Input,Rt as MATROSKA,fr as MKV,Ii as MOV,vi as MP4,oe as MediaSource,Tt as MediaStreamAudioTrackSource,ht as MediaStreamVideoTrackSource,Ue as MkvOutputFormat,lt as Mp4OutputFormat,Ct as Output,Y as OutputFormat,Fe as SUBTITLE_CODECS,xe as Source,nt as StreamTarget,ce as SubtitleSource,G as Target,xt as TextSubtitleSource,ie as VIDEO_CODECS,qe as VideoFrameDrain,ft as VideoFrameSource,W as VideoSource,Ai as WEBM,ne as WebMOutputFormat};
