"use strict";var Metamuxer=(()=>{var mt=Object.defineProperty;var lr=Object.getOwnPropertyDescriptor;var fr=Object.getOwnPropertyNames;var pr=Object.prototype.hasOwnProperty;var hr=(r,e)=>{for(var t in e)mt(r,t,{get:e[t],enumerable:!0})},br=(r,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of fr(e))!pr.call(r,i)&&i!==t&&mt(r,i,{get:()=>e[i],enumerable:!(s=lr(e,i))||s.enumerable});return r};var gr=r=>br(mt({},"__esModule",{value:!0}),r);var Ri={};hr(Ri,{ALL_FORMATS:()=>mr,AUDIO_CODECS:()=>Z,ArrayBufferSource:()=>Je,ArrayBufferTarget:()=>oe,AudioBufferSource:()=>Xe,AudioDataSource:()=>qe,AudioSource:()=>P,BlobSource:()=>et,CanvasSource:()=>Qe,EncodedAudioChunkSource:()=>je,EncodedVideoChunkDrain:()=>ve,EncodedVideoChunkSource:()=>Le,ISOBMFF:()=>ye,Input:()=>ot,MATROSKA:()=>nt,MKV:()=>It,MOV:()=>cr,MP4:()=>or,MediaSource:()=>ee,MediaStreamAudioTrackSource:()=>Ge,MediaStreamVideoTrackSource:()=>Ke,MkvOutputFormat:()=>Te,Mp4OutputFormat:()=>He,Output:()=>Ze,OutputFormat:()=>W,SUBTITLE_CODECS:()=>be,Source:()=>ue,StreamTarget:()=>Pe,SubtitleSource:()=>te,Target:()=>N,TextSubtitleSource:()=>Ye,VIDEO_CODECS:()=>Y,VideoFrameDrain:()=>ct,VideoFrameSource:()=>$e,VideoSource:()=>z,WEBM:()=>ur,WebMOutputFormat:()=>J});function m(r){if(!r)throw new Error("Assertion failed.")}var _=r=>r&&r[r.length-1],L=r=>r>=0&&r<2**32,$=(r,e,t)=>{let s=0;for(let i=e;i<t;i++){let a=Math.floor(i/8),n=r[a],c=7-(i&7),o=(n&1<<c)>>c;s<<=1,s|=o}return s},_t=(r,e,t,s)=>{for(let i=e;i<t;i++){let a=Math.floor(i/8),n=r[a],c=7-(i&7);n&=~(1<<c),n|=(s&1<<t-i-1)>>t-i-1<<c,r[a]=n}},Q=r=>r instanceof ArrayBuffer?new Uint8Array(r):new Uint8Array(r.buffer,r.byteOffset,r.byteLength),O=new TextEncoder,dt=r=>Object.fromEntries(Object.entries(r).map(([e,t])=>[t,e])),K={bt709:1,bt470bg:5,smpte170m:6},Rt=dt(K),j={bt709:1,smpte170m:6,"iec61966-2-1":13},At=dt(j),q={rgb:0,bt709:1,bt470bg:5,smpte170m:6},Ot=dt(q),Re=r=>!!r&&!!r.primaries&&!!r.transfer&&!!r.matrix&&r.fullRange!==void 0,lt=r=>r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer||ArrayBuffer.isView(r)&&!(r instanceof DataView),U=class{currentPromise=Promise.resolve();async acquire(){let e,t=new Promise(i=>{e=i}),s=this.currentPromise;return this.currentPromise=t,await s,e}},B=r=>{let e=r*(Math.PI/180),t=Math.cos(e),s=Math.sin(e);return[t,s,0,-s,t,0,0,0,1]},ft=B(0),Et=r=>[...r].map(e=>e.toString(16).padStart(2,"0")).join(""),Vt=r=>(r=r>>1&1431655765|(r&1431655765)<<1,r=r>>2&858993459|(r&858993459)<<2,r=r>>4&252645135|(r&252645135)<<4,r=r>>8&16711935|(r&16711935)<<8,r=r>>16&65535|(r&65535)<<16,r>>>0),D=(r,e,t)=>{let s=0,i=r.length-1,a=-1;for(;s<=i;){let n=s+i>>1,c=t(r[n]);c===e?(a=n,i=n-1):c<e?s=n+1:i=n-1}return a},I=(r,e,t)=>{let s=-1,i=0,a=r.length-1;for(;i<=a;){let n=i+(a-i+1)/2|0;t(r[n])<=e?(s=n,i=n+1):a=n-1}return s},X=()=>{let r,e;return{promise:new Promise((s,i)=>{r=s,e=i}),resolve:r,reject:e}},Ft=(r,e)=>{let t=r.indexOf(e);t!==-1&&r.splice(t,1)};var le=/(?:(.+?)\n)?((?:\d{2}:)?\d{2}:\d{2}.\d{3})\s+-->\s+((?:\d{2}:)?\d{2}:\d{2}.\d{3})/g,kr=/^WEBVTT(.|\n)*?\n{2}/,se=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,Ae=class{options;preambleText=null;preambleEmitted=!1;constructor(e){this.options=e}parse(e){e=e.replaceAll(`\r
`,`
`).replaceAll("\r",`
`),le.lastIndex=0;let t;if(!this.preambleText){if(!kr.test(e)){let i=new Error("WebVTT preamble incorrect.");throw this.options.error(i),i}t=le.exec(e);let s=e.slice(0,t?.index??e.length).trimEnd();if(!s){let i=new Error("No WebVTT preamble provided.");throw this.options.error(i),i}this.preambleText=s,t&&(e=e.slice(t.index),le.lastIndex=0)}for(;t=le.exec(e);){let s=e.slice(0,t.index),i=t[1],a=t.index+t[0].length,n=e.indexOf(`
`,a)+1,c=e.slice(a,n).trim(),o=e.indexOf(`

`,a);o===-1&&(o=e.length);let u=Oe(t[2]),l=Oe(t[3])-u,g=e.slice(n,o).trim();e=e.slice(o).trimStart(),le.lastIndex=0;let h={timestamp:u/1e3,duration:l/1e3,text:g,identifier:i,settings:c,notes:s},b={};this.preambleEmitted||(b.config={description:this.preambleText},this.preambleEmitted=!0),this.options.output(h,b)}}},Tr=/(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})/,Oe=r=>{let e=Tr.exec(r);if(!e)throw new Error("Expected match.");return 60*60*1e3*Number(e[1]||"0")+60*1e3*Number(e[2])+1e3*Number(e[3])+Number(e[4])},Ee=r=>{let e=Math.floor(r/36e5),t=Math.floor(r%(60*60*1e3)/(60*1e3)),s=Math.floor(r%(60*1e3)/1e3),i=r%1e3;return e.toString().padStart(2,"0")+":"+t.toString().padStart(2,"0")+":"+s.toString().padStart(2,"0")+"."+i.toString().padStart(3,"0")};var fe=class{constructor(e){this.writer=e}helper=new Uint8Array(8);helperView=new DataView(this.helper.buffer);offsets=new WeakMap;writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let t=0;t<e.length;t++)this.helperView.setUint8(t%8,e.charCodeAt(t)),t%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{let t=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(let a of e.children)a&&this.writeBox(a);let s=this.writer.getPos(),i=e.size??s-t;this.writer.seek(t),this.writeBoxHeader(e,i),this.writer.seek(s)}}writeBoxHeader(e,t){this.writeU32(e.largeSize?1:t),this.writeAscii(e.type),e.largeSize&&this.writeU64(t)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){let t=this.offsets.get(e);m(t!==void 0);let s=this.writer.getPos();this.writer.seek(t),this.writeBox(e),this.writer.seek(s)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let t=this.measureBoxHeader(e);if(e.contents&&(t+=e.contents.byteLength),e.children)for(let s of e.children)s&&(t+=this.measureBox(s));return t}}},k=new Uint8Array(8),M=new DataView(k.buffer),v=r=>[(r%256+256)%256],T=r=>(M.setUint16(0,r,!1),[k[0],k[1]]),xr=r=>(M.setInt16(0,r,!1),[k[0],k[1]]),zt=r=>(M.setUint32(0,r,!1),[k[1],k[2],k[3]]),f=r=>(M.setUint32(0,r,!1),[k[0],k[1],k[2],k[3]]),Pt=r=>(M.setInt32(0,r,!1),[k[0],k[1],k[2],k[3]]),G=r=>(M.setUint32(0,Math.floor(r/2**32),!1),M.setUint32(4,r,!1),[k[0],k[1],k[2],k[3],k[4],k[5],k[6],k[7]]),bt=r=>(M.setInt16(0,2**8*r,!1),[k[0],k[1]]),F=r=>(M.setInt32(0,2**16*r,!1),[k[0],k[1],k[2],k[3]]),pt=r=>(M.setInt32(0,2**30*r,!1),[k[0],k[1],k[2],k[3]]),ht=(r,e)=>{let t=[],s=r;do{let i=s&127;s>>=7,t.length>0&&(i|=128),t.push(i),e!==void 0&&e--}while(s>0||e);return t.reverse()},R=(r,e=!1)=>{let t=Array(r.length).fill(null).map((s,i)=>r.charCodeAt(i));return e&&t.push(0),t},gt=r=>{let e=null;for(let t of r)(!e||t.timestamp>e.timestamp)&&(e=t);return e},Dt=r=>[F(r[0]),F(r[1]),pt(r[2]),F(r[3]),F(r[4]),pt(r[5]),F(r[6]),F(r[7]),pt(r[8])],S=(r,e,t)=>({type:r,contents:e&&new Uint8Array(e.flat(10)),children:t}),C=(r,e,t,s,i)=>S(r,[v(e),zt(t),s??[]],i),Ut=r=>r.fragmented?S("ftyp",[R("iso5"),f(512),R("iso5"),R("iso6"),R("mp41")]):S("ftyp",[R("isom"),f(512),R("isom"),r.holdsAvc?R("avc1"):[],R("mp41")]),Fe=r=>({type:"mdat",largeSize:r}),Bt=r=>({type:"free",size:r}),pe=(r,e,t=!1)=>S("moov",void 0,[Sr(e,r),...r.map(s=>Cr(s,e)),t?ti(r):null]),Sr=(r,e)=>{let t=E(Math.max(0,...e.filter(n=>n.samples.length>0).map(n=>{let c=gt(n.samples);return c.timestamp+c.duration})),Ve),s=Math.max(0,...e.map(n=>n.track.id))+1,i=!L(r)||!L(t),a=i?G:f;return C("mvhd",+i,0,[a(r),a(r),f(Ve),a(t),F(1),bt(1),Array(10).fill(0),Dt(ft),Array(24).fill(0),f(s)])},Cr=(r,e)=>S("trak",void 0,[wr(r,e),yr(r,e)]),wr=(r,e)=>{let t=gt(r.samples),s=E(t?t.timestamp+t.duration:0,Ve),i=!L(e)||!L(s),a=i?G:f,n;if(r.type==="video"){let c=r.track.metadata.rotation;n=c===void 0||typeof c=="number"?B(c??0):c}else n=ft;return C("tkhd",+i,3,[a(e),a(e),f(r.track.id),f(0),a(s),Array(8).fill(0),T(0),T(r.track.id),bt(r.type==="audio"?1:0),T(0),Dt(n),F(r.type==="video"?r.info.width:0),F(r.type==="video"?r.info.height:0)])},yr=(r,e)=>S("mdia",void 0,[vr(r,e),Rr(r),Ar(r)]),vr=(r,e)=>{let t=gt(r.samples),s=E(t?t.timestamp+t.duration:0,r.timescale),i=!L(e)||!L(s),a=i?G:f;return C("mdhd",+i,0,[a(e),a(e),f(r.timescale),a(s),T(21956),T(0)])},Ir={video:"vide",audio:"soun",subtitle:"text"},_r={video:"VideoHandler",audio:"SoundHandler",subtitle:"TextHandler"},Rr=r=>C("hdlr",0,0,[R("mhlr"),R(Ir[r.type]),f(0),f(0),f(0),R(_r[r.type],!0)]),Ar=r=>S("minf",void 0,[Fr[r.type](),Mr(),Dr(r)]),Or=()=>C("vmhd",0,1,[T(0),T(0),T(0),T(0)]),Er=()=>C("smhd",0,0,[T(0),T(0)]),Vr=()=>C("nmhd",0,0),Fr={video:Or,audio:Er,subtitle:Vr},Mr=()=>S("dinf",void 0,[zr()]),zr=()=>C("dref",0,0,[f(1)],[Pr()]),Pr=()=>C("url ",0,1),Dr=r=>{let e=r.compositionTimeOffsetTable.length>1||r.compositionTimeOffsetTable.some(t=>t.sampleCompositionTimeOffset!==0);return S("stbl",void 0,[Ur(r),Xr(r),Gr(r),Yr(r),Zr(r),Jr(r),e?ei(r):null])},Ur=r=>{let e;return r.type==="video"?e=Br(mi[r.track.source._codec],r):r.type==="audio"?e=$r(li[r.track.source._codec],r):r.type==="subtitle"&&(e=jr(pi[r.track.source._codec],r)),m(e),C("stsd",0,0,[f(1)],[e])},Br=(r,e)=>S(r,[Array(6).fill(0),T(1),T(0),T(0),Array(12).fill(0),T(e.info.width),T(e.info.height),f(4718592),f(4718592),f(0),T(1),Array(32).fill(0),T(24),xr(65535)],[di[e.track.source._codec](e),Re(e.info.decoderConfig.colorSpace)?Nr(e):null]),Nr=r=>S("colr",[R("nclx"),T(K[r.info.decoderConfig.colorSpace.primaries]),T(j[r.info.decoderConfig.colorSpace.transfer]),T(q[r.info.decoderConfig.colorSpace.matrix]),v((r.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),Wr=r=>r.info.decoderConfig&&S("avcC",[...Q(r.info.decoderConfig.description)]),Hr=r=>r.info.decoderConfig&&S("hvcC",[...Q(r.info.decoderConfig.description)]),Mt=r=>{if(!r.info.decoderConfig)return null;let e=r.info.decoderConfig;m(e.colorSpace);let t=e.codec.split("."),s=Number(t[1]),i=Number(t[2]),c=(Number(t[3])<<4)+(0<<1)+Number(e.colorSpace.fullRange);return C("vpcC",1,0,[v(s),v(i),v(c),v(2),v(2),v(2),T(0)])},Lr=()=>S("av1C",[129,0,0,0]),$r=(r,e)=>S(r,[Array(6).fill(0),T(1),T(0),T(0),f(0),T(e.info.numberOfChannels),T(16),T(0),T(0),F(e.info.sampleRate)],[fi[e.track.source._codec](e)]),Qr=r=>{let t=[...Q(r.info.decoderConfig.description??new ArrayBuffer(0))];return t=[...v(64),...v(21),...zt(0),...f(0),...f(0),...v(5),...ht(t.length),...t],t=[...T(1),...v(0),...v(4),...ht(t.length),...t,...v(6),...v(1),...v(2)],t=[...v(3),...ht(t.length),...t],C("esds",0,0,t)},Kr=r=>{let e=3840,t=0,s=r.info.decoderConfig?.description;if(s){m(s.byteLength>=18);let i=ArrayBuffer.isView(s)?new DataView(s.buffer,s.byteOffset,s.byteLength):new DataView(s);e=i.getUint16(10,!0),t=i.getInt16(14,!0)}return S("dOps",[v(0),v(r.info.numberOfChannels),T(e),f(r.info.sampleRate),bt(t),v(0)])},jr=(r,e)=>S(r,[Array(6).fill(0),T(1)],[hi[e.track.source._codec](e)]),qr=r=>S("vttC",[...O.encode(r.info.config.description)]);var Xr=r=>C("stts",0,0,[f(r.timeToSampleTable.length),r.timeToSampleTable.map(e=>[f(e.sampleCount),f(e.sampleDelta)])]),Gr=r=>{if(r.samples.every(t=>t.type==="key"))return null;let e=[...r.samples.entries()].filter(([,t])=>t.type==="key");return C("stss",0,0,[f(e.length),e.map(([t])=>f(t+1))])},Yr=r=>C("stsc",0,0,[f(r.compactlyCodedChunkTable.length),r.compactlyCodedChunkTable.map(e=>[f(e.firstChunk),f(e.samplesPerChunk),f(1)])]),Zr=r=>C("stsz",0,0,[f(0),f(r.samples.length),r.samples.map(e=>f(e.size))]),Jr=r=>r.finalizedChunks.length>0&&_(r.finalizedChunks).offset>=2**32?C("co64",0,0,[f(r.finalizedChunks.length),r.finalizedChunks.map(e=>G(e.offset))]):C("stco",0,0,[f(r.finalizedChunks.length),r.finalizedChunks.map(e=>f(e.offset))]),ei=r=>C("ctts",0,0,[f(r.compositionTimeOffsetTable.length),r.compositionTimeOffsetTable.map(e=>[f(e.sampleCount),f(e.sampleCompositionTimeOffset)])]),ti=r=>S("mvex",void 0,r.map(ri)),ri=r=>C("trex",0,0,[f(r.track.id),f(1),f(0),f(0),f(0)]),kt=(r,e)=>S("moof",void 0,[ii(r),...e.map(si)]),ii=r=>C("mfhd",0,0,[f(r)]),Nt=r=>{let e=0,t=0,s=0,i=0,a=r.type==="delta";return t|=+a,a?e|=1:e|=2,e<<24|t<<16|s<<8|i},si=r=>S("traf",void 0,[ai(r),ni(r),oi(r)]),ai=r=>{m(r.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;let t=r.currentChunk.samples[1]??r.currentChunk.samples[0],s={duration:t.timescaleUnitsToNextSample,size:t.size,flags:Nt(t)};return C("tfhd",0,e,[f(r.track.id),f(s.duration),f(s.size),f(s.flags)])},ni=r=>(m(r.currentChunk),C("tfdt",1,0,[G(E(r.currentChunk.startTimestamp,r.timescale))])),oi=r=>{m(r.currentChunk);let e=r.currentChunk.samples.map(p=>p.timescaleUnitsToNextSample),t=r.currentChunk.samples.map(p=>p.size),s=r.currentChunk.samples.map(Nt),i=r.currentChunk.samples.map(p=>E(p.timestamp-p.decodeTimestamp,r.timescale)),a=new Set(e),n=new Set(t),c=new Set(s),o=new Set(i),u=c.size===2&&s[0]!==s[1],d=a.size>1,l=n.size>1,g=!u&&c.size>1,h=o.size>1||[...o].some(p=>p!==0),b=0;return b|=1,b|=4*+u,b|=256*+d,b|=512*+l,b|=1024*+g,b|=2048*+h,C("trun",1,b,[f(r.currentChunk.samples.length),f(r.currentChunk.offset-r.currentChunk.moofOffset||0),u?f(s[0]):[],r.currentChunk.samples.map((p,x)=>[d?f(e[x]):[],l?f(t[x]):[],g?f(s[x]):[],h?Pt(i[x]):[]])])},Wt=r=>S("mfra",void 0,[...r.map(ci),ui()]),ci=(r,e)=>C("tfra",1,0,[f(r.track.id),f(63),f(r.finalizedChunks.length),r.finalizedChunks.map(s=>[G(E(s.samples[0].timestamp,r.timescale)),G(s.moofOffset),f(e+1),f(1),f(1)])]),ui=()=>C("mfro",0,0,[f(0)]),Ht=()=>S("vtte"),Lt=(r,e,t,s,i)=>S("vttc",void 0,[i!==null?S("vsid",[Pt(i)]):null,t!==null?S("iden",[...O.encode(t)]):null,e!==null?S("ctim",[...O.encode(Ee(e))]):null,s!==null?S("sttg",[...O.encode(s)]):null,S("payl",[...O.encode(r)])]),$t=r=>S("vtta",[...O.encode(r)]),mi={avc:"avc1",hevc:"hvc1",vp8:"vp08",vp9:"vp09",av1:"av01"},di={avc:Wr,hevc:Hr,vp8:Mt,vp9:Mt,av1:Lr},li={aac:"mp4a",opus:"Opus"},fi={aac:Qr,opus:Kr},pi={webvtt:"wvtt"},hi={webvtt:qr};var ae=class{output;mutex=new U;constructor(e){this.output=e}beforeTrackAdd(e){}onTrackClose(e){}trackTimestampInfo=new WeakMap;validateAndNormalizeTimestamp(e,t,s){let i=t/1e6,a=this.trackTimestampInfo.get(e);if(!a){if(!s)throw new Error("First frame must be a key frame.");if(this.timestampsMustStartAtZero&&i>0)throw new Error(`Timestamps must start at zero (got ${i}s).`);a={timestampOffset:i,maxTimestamp:e.source._offsetTimestamps?0:i,lastKeyFrameTimestamp:e.source._offsetTimestamps?0:i},this.trackTimestampInfo.set(e,a)}if(e.source._offsetTimestamps&&(i-=a.timestampOffset),i<0)throw new Error(`Timestamps must be non-negative (got ${i}s).`);if(i<a.lastKeyFrameTimestamp)throw new Error(`Timestamp cannot be smaller than last key frame's timestamp (got ${i}s, last key frame at ${a.lastKeyFrameTimestamp}s).`);if(s){if(i<a.maxTimestamp)throw new Error(`Key frame timestamps cannot be smaller than any timestamp that came before (got ${i}s, max timestamp was ${a.maxTimestamp}s).`);a.lastKeyFrameTimestamp=i}return a.maxTimestamp=Math.max(a.maxTimestamp,i),i}};var he=class{ensureMonotonicity=!1;start(){}},ne=class extends he{pos=0;target;buffer=new ArrayBuffer(2**16);bytes=new Uint8Array(this.buffer);maxPos=0;constructor(e){super(),this.target=e}ensureSize(e){let t=this.buffer.byteLength;for(;t<e;)t*=2;if(t===this.buffer.byteLength)return;let s=new ArrayBuffer(t),i=new Uint8Array(s);i.set(this.bytes,0),this.buffer=s,this.bytes=i}write(e){this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}getSlice(e,t){return this.bytes.slice(e,t)}},Me=class extends he{pos=0;target;sections=[];lastFlushEnd=0;writer=null;constructor(e){super(),this.target=e}start(){this.writer=this.target._writable.getWriter()}write(e){this.sections.push({data:e.slice(),start:this.pos}),this.pos+=e.byteLength}seek(e){this.pos=e}getPos(){return this.pos}async flush(){if(m(this.writer),this.sections.length===0)return;let e=[],t=[...this.sections].sort((s,i)=>s.start-i.start);e.push({start:t[0].start,size:t[0].data.byteLength});for(let s=1;s<t.length;s++){let i=e[e.length-1],a=t[s];a.start<=i.start+i.size?i.size=Math.max(i.size,a.start+a.data.byteLength-i.start):e.push({start:a.start,size:a.data.byteLength})}for(let s of e){s.data=new Uint8Array(s.size);for(let i of this.sections)s.start<=i.start&&i.start<s.start+s.size&&s.data.set(i.data,i.start-s.start);if(this.ensureMonotonicity&&s.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.writer.write({type:"write",data:s.data,position:s.start}),this.lastFlushEnd=s.start+s.data.byteLength}this.sections.length=0}finalize(){return m(this.writer),this.writer.close()}},bi=2**24,gi=2,ze=class extends he{pos=0;target;chunkSize;chunks=[];lastFlushEnd=0;writer=null;flushedChunkQueue=[];constructor(e){if(super(),this.target=e,this.chunkSize=e._options?.chunkSize??bi,!Number.isInteger(this.chunkSize)||this.chunkSize<2**10)throw new Error("Invalid StreamTarget options: chunkSize must be an integer not smaller than 1024.")}start(){this.writer=this.target._writable.getWriter()}write(e){this.writeDataIntoChunks(e,this.pos),this.queueChunksForFlush(),this.pos+=e.byteLength}seek(e){this.pos=e}getPos(){return this.pos}writeDataIntoChunks(e,t){let s=this.chunks.findIndex(o=>o.start<=t&&t<o.start+this.chunkSize);s===-1&&(s=this.createChunk(t));let i=this.chunks[s],a=t-i.start,n=e.subarray(0,Math.min(this.chunkSize-a,e.byteLength));i.data.set(n,a);let c={start:a,end:a+n.byteLength};if(this.insertSectionIntoChunk(i,c),i.written[0].start===0&&i.written[0].end===this.chunkSize&&(i.shouldFlush=!0),this.chunks.length>gi){for(let o=0;o<this.chunks.length-1;o++)this.chunks[o].shouldFlush=!0;this.queueChunksForFlush()}n.byteLength<e.byteLength&&this.writeDataIntoChunks(e.subarray(n.byteLength),t+n.byteLength)}insertSectionIntoChunk(e,t){let s=0,i=e.written.length-1,a=-1;for(;s<=i;){let n=Math.floor(s+(i-s+1)/2);e.written[n].start<=t.start?(s=n+1,a=n):i=n-1}for(e.written.splice(a+1,0,t),(a===-1||e.written[a].end<t.start)&&a++;a<e.written.length-1&&e.written[a].end>=e.written[a+1].start;)e.written[a].end=Math.max(e.written[a].end,e.written[a+1].end),e.written.splice(a+1,1)}createChunk(e){let s={start:Math.floor(e/this.chunkSize)*this.chunkSize,data:new Uint8Array(this.chunkSize),written:[],shouldFlush:!1};return this.chunks.push(s),this.chunks.sort((i,a)=>i.start-a.start),this.chunks.indexOf(s)}queueChunksForFlush(e=!1){m(this.writer);for(let t=0;t<this.chunks.length;t++){let s=this.chunks[t];if(!(!s.shouldFlush&&!e)){for(let i of s.written){if(this.ensureMonotonicity&&s.start+i.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.flushedChunkQueue.push({type:"write",data:s.data.subarray(i.start,i.end),position:s.start+i.start}),this.lastFlushEnd=s.start+i.end}this.chunks.splice(t--,1)}}}async flush(){if(m(this.writer),this.flushedChunkQueue.length!==0){for(let e of this.flushedChunkQueue)this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.writer.write(e);this.flushedChunkQueue.length=0}}async finalize(){return m(this.writer),this.queueChunksForFlush(!0),await this.flush(),this.writer.close()}};var N=class{_output=null},oe=class extends N{buffer=null;_createWriter(){return new ne(this)}},Pe=class extends N{_writable;_options;constructor(e,t={}){if(super(),!(e instanceof WritableStream))throw new TypeError("StreamTarget requires a WritableStream instance.");if(t!=null&&typeof t!="object")throw new TypeError("StreamTarget options, when provided, must be an object.");if(t.chunked!==void 0&&typeof t.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(t.chunkSize!==void 0&&(!Number.isInteger(t.chunkSize)||t.chunkSize<=0))throw new TypeError("options.chunkSize, when provided, must be a positive integer.");this._writable=e,this._options=t}_createWriter(){return this._options.chunked?new ze(this):new Me(this)}};var Y=["avc","hevc","vp8","vp9","av1"],Z=["aac","opus"],be=["webvtt"],Qt=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],Kt=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],jt=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],qt=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],Xt=(r,e,t,s)=>{if(r==="avc"){let a=Math.ceil(e/16)*Math.ceil(t/16),n=Qt.find(l=>a<=l.maxMacroblocks&&s<=l.maxBitrate)??_(Qt),c=n?n.level:0,o="64".padStart(2,"0"),u="00",d=c.toString(16).padStart(2,"0");return`avc1.${o}${u}${d}`}else if(r==="hevc"){let i="",n="6",c=e*t,o=Kt.find(d=>c<=d.maxPictureSize&&s<=d.maxBitrate)??_(Kt);return`hev1.${i}1.${n}.${o.tier}${o.level}.B0`}else{if(r==="vp8")return"vp8";if(r==="vp9"){let i="00",a=e*t,n=jt.find(o=>a<=o.maxPictureSize&&s<=o.maxBitrate)??_(jt);return`vp09.${i}.${n.level}.08`}else if(r==="av1"){let a=e*t,n=qt.find(o=>a<=o.maxPictureSize&&s<=o.maxBitrate)??_(qt);return`av01.0.${n.level.toString().padStart(2,"0")}${n.tier}.08`}}throw new TypeError(`Unhandled codec '${r}'.`)},Gt=(r,e)=>{if(r==="avc"){if(!e||e.byteLength<4)throw new TypeError("AVC description must be at least 4 bytes long.");return`avc1.${Et(e.subarray(1,4))}`}else if(r==="hevc"){if(!e)throw new TypeError("HEVC description must be provided.");let t=new DataView(e.buffer,e.byteOffset,e.byteLength),s="hev1.",i=e[1]>>6&3,a=e[1]&31;s+=["","A","B","C"][i]+a,s+=".";let n=Vt(t.getUint32(2));s+=n.toString(16),s+=".";let c=e[1]>>5&1,o=e[12];s+=c===0?"L":"H",s+=o,s+=".";let u=[];for(let d=0;d<6;d++){let l=e[d+13];u.push(l)}for(;u[u.length-1]===0;)u.pop();return s+=u.map(d=>d.toString(16)).join("."),s}throw new TypeError(`Unhandled codec '${r}'.`)},Yt=(r,e,t)=>{if(r==="aac")return e>=2&&t<=24e3?"mp4a.40.29":t<=24e3?"mp4a.40.5":"mp4a.40.2";if(r==="opus")return"opus";if(r==="vorbis")return"vorbis";throw new TypeError(`Unhandled codec '${r}'.`)},Zt=(r,e)=>{if(r==="aac"){if(!e||e.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");return`mp4a.40.${e[0]>>3}`}else{if(r==="opus")return"opus";if(r==="vorbis")return"vorbis"}throw new TypeError(`Unhandled codec '${r}'.`)},Jt=r=>r==="avc"?{avc:{format:"avc"}}:r==="hevc"?{hevc:{format:"hevc"}}:{},er=r=>r==="aac"?{aac:{format:"aac"}}:r==="opus"?{opus:{format:"opus"}}:{},De=r=>{if(!r)throw new TypeError("Video chunk metadata must be provided.");if(typeof r!="object")throw new TypeError("Video chunk metadata must be an object.");if(!r.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof r.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof r.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!Number.isInteger(r.decoderConfig.codedWidth)||r.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(r.decoderConfig.codedHeight)||r.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(r.decoderConfig.description!==void 0&&!lt(r.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(r.decoderConfig.colorSpace!==void 0){let{colorSpace:e}=r.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");let t=Object.keys(K);if(e.primaries!=null&&!t.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${t.join(", ")}.`);let s=Object.keys(j);if(e.transfer!=null&&!s.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${s.join(", ")}.`);let i=Object.keys(q);if(e.matrix!=null&&!i.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${i.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if((r.decoderConfig.codec.startsWith("avc1")||r.decoderConfig.codec.startsWith("avc3"))&&!r.decoderConfig.description)throw new TypeError("Video chunk metadata decoder configuration for AVC must include a description, which is expected to be an AVCDecoderConfigurationRecord as specified in ISO 14496-15.");if((r.decoderConfig.codec.startsWith("hev1")||r.decoderConfig.codec.startsWith("hvc1"))&&!r.decoderConfig.description)throw new TypeError("Video chunk metadata decoder configuration for HEVC must include a description, which is expected to be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15.");if((r.decoderConfig.codec==="vp8"||r.decoderConfig.codec.startsWith("vp09"))&&r.decoderConfig.colorSpace===void 0)throw new TypeError("Video chunk metadata decoder configuration for VP8/VP9 must include a colorSpace.")},Ue=r=>{if(!r)throw new TypeError("Audio chunk metadata must be provided.");if(typeof r!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!r.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof r.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof r.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Number.isInteger(r.decoderConfig.sampleRate)||r.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(r.decoderConfig.numberOfChannels)||r.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(r.decoderConfig.description!==void 0&&!lt(r.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(r.decoderConfig.codec.startsWith("mp4a")&&!r.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.");if(r.decoderConfig.codec==="opus"&&r.decoderConfig.description&&r.decoderConfig.description.byteLength<18)throw new TypeError("Invalid decoder description provided for Opus; must be at least 18 bytes long.")},Be=r=>{if(!r)throw new TypeError("Subtitle metadata must be provided.");if(typeof r!="object")throw new TypeError("Subtitle metadata must be an object.");if(!r.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof r.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof r.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};var Ve=1e3,ki=2082844800,E=(r,e,t=!0)=>{let s=r*e;return t?Math.round(s):s},Ne=class extends ae{timestampsMustStartAtZero=!0;writer;boxWriter;fastStart;auxTarget=new oe;auxWriter=this.auxTarget._createWriter();auxBoxWriter=new fe(this.auxWriter);ftypSize=null;mdat=null;trackDatas=[];creationTime=Math.floor(Date.now()/1e3)+ki;finalizedChunks=[];nextFragmentNumber=1;constructor(e,t){super(e),this.writer=e._writer,this.boxWriter=new fe(this.writer);let s=this.writer instanceof ne?"in-memory":!1;this.fastStart=t._options.fastStart??s,(this.fastStart==="in-memory"||this.fastStart==="fragmented")&&(this.writer.ensureMonotonicity=!0)}async start(){let e=await this.mutex.acquire(),t=this.output._tracks.some(s=>s.type==="video"&&s.source._codec==="avc");this.boxWriter.writeBox(Ut({holdsAvc:t,fragmented:this.fastStart==="fragmented"})),this.ftypSize=this.writer.getPos(),this.fastStart==="in-memory"?this.mdat=Fe(!1):this.fastStart==="fragmented"||(this.mdat=Fe(!0),this.boxWriter.writeBox(this.mdat)),await this.writer.flush(),e()}getVideoTrackData(e,t){let s=this.trackDatas.find(a=>a.track===e);if(s)return s;De(t),m(t),m(t.decoderConfig),m(t.decoderConfig.codedWidth!==void 0),m(t.decoderConfig.codedHeight!==void 0);let i={track:e,type:"video",info:{width:t.decoderConfig.codedWidth,height:t.decoderConfig.codedHeight,decoderConfig:t.decoderConfig},timescale:e.metadata.frameRate??57600,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(i),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),i}getAudioTrackData(e,t){let s=this.trackDatas.find(a=>a.track===e);if(s)return s;Ue(t),m(t),m(t.decoderConfig);let i={track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig},timescale:t.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(i),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),i}getSubtitleTrackData(e,t){let s=this.trackDatas.find(a=>a.track===e);if(s)return s;Be(t),m(t),m(t.config);let i={track:e,type:"subtitle",info:{config:t.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(i),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),this.validateAndNormalizeTimestamp(e,0,!0),i}async addEncodedVideoChunk(e,t,s){let i=await this.mutex.acquire();try{let a=this.getVideoTrackData(e,s),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=this.validateAndNormalizeTimestamp(a.track,t.timestamp,t.type==="key"),o=this.createSampleForTrack(a,n,c,(t.duration??0)/1e6,t.type);await this.registerSample(a,o)}finally{i()}}async addEncodedAudioChunk(e,t,s){let i=await this.mutex.acquire();try{let a=this.getAudioTrackData(e,s),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=t.type,o=this.validateAndNormalizeTimestamp(a.track,t.timestamp,c==="key"),u=this.createSampleForTrack(a,n,o,(t.duration??0)/1e6,c);await this.registerSample(a,u)}finally{i()}}async addSubtitleCue(e,t,s){let i=await this.mutex.acquire();try{let a=this.getSubtitleTrackData(e,s);this.validateAndNormalizeTimestamp(a.track,1e6*t.timestamp,!0),e.source._codec==="webvtt"&&(a.cueQueue.push(t),await this.processWebVTTCues(a,t.timestamp))}finally{i()}}async processWebVTTCues(e,t){for(;e.cueQueue.length>0;){let s=new Set([]);for(let u of e.cueQueue)m(u.timestamp<=t),m(e.lastCueEndTimestamp<=u.timestamp+u.duration),s.add(Math.max(u.timestamp,e.lastCueEndTimestamp)),s.add(u.timestamp+u.duration);let i=[...s].sort((u,d)=>u-d),a=i[0],n=i[1]??a;if(t<n)break;if(e.lastCueEndTimestamp<a){this.auxWriter.seek(0);let u=Ht();this.auxBoxWriter.writeBox(u);let d=this.auxWriter.getSlice(0,this.auxWriter.getPos()),l=this.createSampleForTrack(e,d,e.lastCueEndTimestamp,a-e.lastCueEndTimestamp,"key");await this.registerSample(e,l),e.lastCueEndTimestamp=a}this.auxWriter.seek(0);for(let u=0;u<e.cueQueue.length;u++){let d=e.cueQueue[u];if(d.timestamp>=n)break;se.lastIndex=0;let l=se.test(d.text),g=d.timestamp+d.duration,h=e.cueToSourceId.get(d);if(h===void 0&&n<g&&(h=e.nextSourceId++,e.cueToSourceId.set(d,h)),d.notes){let p=$t(d.notes);this.auxBoxWriter.writeBox(p)}let b=Lt(d.text,l?a:null,d.identifier??null,d.settings??null,h??null);this.auxBoxWriter.writeBox(b),g===n&&e.cueQueue.splice(u--,1)}let c=this.auxWriter.getSlice(0,this.auxWriter.getPos()),o=this.createSampleForTrack(e,c,a,n-a,"key");await this.registerSample(e,o),e.lastCueEndTimestamp=n}}createSampleForTrack(e,t,s,i,a){return{timestamp:s,decodeTimestamp:s,duration:i,data:t,size:t.byteLength,type:a,timescaleUnitsToNextSample:E(i,e.timescale)}}processTimestamps(e){if(e.timestampProcessingQueue.length===0)return;let t=e.timestampProcessingQueue.map(s=>s.timestamp).sort((s,i)=>s-i);for(let s=0;s<e.timestampProcessingQueue.length;s++){let i=e.timestampProcessingQueue[s];i.decodeTimestamp=t[s];let a=E(i.timestamp-i.decodeTimestamp,e.timescale),n=E(i.duration,e.timescale);if(e.lastTimescaleUnits!==null){m(e.lastSample);let c=E(i.decodeTimestamp,e.timescale,!1),o=Math.round(c-e.lastTimescaleUnits);if(e.lastTimescaleUnits+=o,e.lastSample.timescaleUnitsToNextSample=o,this.fastStart!=="fragmented"){let u=_(e.timeToSampleTable);if(m(u),u.sampleCount===1){u.sampleDelta=o;let l=e.timeToSampleTable[e.timeToSampleTable.length-2];l&&l.sampleDelta===o&&(l.sampleCount++,e.timeToSampleTable.pop(),u=l)}else u.sampleDelta!==o&&(u.sampleCount--,e.timeToSampleTable.push(u={sampleCount:1,sampleDelta:o}));u.sampleDelta===n?u.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:n});let d=_(e.compositionTimeOffsetTable);m(d),d.sampleCompositionTimeOffset===a?d.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a})}}else e.lastTimescaleUnits=0,this.fastStart!=="fragmented"&&(e.timeToSampleTable.push({sampleCount:1,sampleDelta:n}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a}));e.lastSample=i}e.timestampProcessingQueue.length=0}async registerSample(e,t){this.fastStart==="fragmented"?(e.sampleQueue.push(t),await this.interleaveSamples()):await this.addSampleToTrack(e,t)}async addSampleToTrack(e,t){t.type==="key"&&this.processTimestamps(e),this.fastStart!=="fragmented"&&e.samples.push(t);let s=!1;if(!e.currentChunk)s=!0;else{let i=t.timestamp-e.currentChunk.startTimestamp;if(this.fastStart==="fragmented"){let a=this.trackDatas.every(n=>{if(e===n)return t.type==="key";let c=n.sampleQueue[0];return c&&c.type==="key"});i>=1&&a&&(s=!0,await this.finalizeFragment())}else s=i>=.5}s&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:t.timestamp,samples:[],offset:null,moofOffset:null}),m(e.currentChunk),e.currentChunk.samples.push(t),e.timestampProcessingQueue.push(t)}async finalizeCurrentChunk(e){if(m(this.fastStart!=="fragmented"),!!e.currentChunk){if(e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk),(e.compactlyCodedChunkTable.length===0||_(e.compactlyCodedChunkTable).samplesPerChunk!==e.currentChunk.samples.length)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:e.currentChunk.samples.length}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(let t of e.currentChunk.samples)m(t.data),this.writer.write(t.data),t.data=null;await this.writer.flush()}}async interleaveSamples(){m(this.fastStart==="fragmented");for(let e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return;e:for(;;){let e=null,t=1/0;for(let i of this.trackDatas){if(i.sampleQueue.length===0&&!i.track.source._closed)break e;i.sampleQueue.length>0&&i.sampleQueue[0].timestamp<t&&(e=i,t=i.sampleQueue[0].timestamp)}if(!e)break;let s=e.sampleQueue.shift();await this.addSampleToTrack(e,s)}}async finalizeFragment(e=!0){m(this.fastStart==="fragmented");let t=this.nextFragmentNumber++;if(t===1){let o=pe(this.trackDatas,this.creationTime,!0);this.boxWriter.writeBox(o)}let s=this.trackDatas.filter(o=>o.currentChunk),i=this.writer.getPos(),a=kt(t,s);this.boxWriter.writeBox(a);{let o=Fe(!1),u=0;for(let l of s)for(let g of l.currentChunk.samples)u+=g.size;let d=this.boxWriter.measureBox(o)+u;d>=2**32&&(o.largeSize=!0,d=this.boxWriter.measureBox(o)+u),o.size=d,this.boxWriter.writeBox(o)}for(let o of s){o.currentChunk.offset=this.writer.getPos(),o.currentChunk.moofOffset=i;for(let u of o.currentChunk.samples)this.writer.write(u.data),u.data=null}let n=this.writer.getPos();this.writer.seek(this.boxWriter.offsets.get(a));let c=kt(t,s);this.boxWriter.writeBox(c),this.writer.seek(n);for(let o of s)o.finalizedChunks.push(o.currentChunk),this.finalizedChunks.push(o.currentChunk),o.currentChunk=null;e&&await this.writer.flush()}async onTrackClose(e){let t=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){let s=this.trackDatas.find(i=>i.track===e);s&&await this.processWebVTTCues(s,1/0)}this.fastStart==="fragmented"&&await this.interleaveSamples(),t()}async finalize(){let e=await this.mutex.acquire();for(let t of this.trackDatas)t.type==="subtitle"&&t.track.source._codec==="webvtt"&&await this.processWebVTTCues(t,1/0);if(this.fastStart==="fragmented"){for(let t of this.trackDatas){for(let s of t.sampleQueue)await this.addSampleToTrack(t,s);this.processTimestamps(t)}await this.finalizeFragment(!1)}else for(let t of this.trackDatas)this.processTimestamps(t),await this.finalizeCurrentChunk(t);if(this.fastStart==="in-memory"){m(this.mdat);let t;for(let i=0;i<2;i++){let a=pe(this.trackDatas,this.creationTime),n=this.boxWriter.measureBox(a);t=this.boxWriter.measureBox(this.mdat);let c=this.writer.getPos()+n+t;for(let o of this.finalizedChunks){o.offset=c;for(let{data:u}of o.samples)m(u),c+=u.byteLength,t+=u.byteLength}if(c<2**32)break;t>=2**32&&(this.mdat.largeSize=!0)}let s=pe(this.trackDatas,this.creationTime);this.boxWriter.writeBox(s),this.mdat.size=t,this.boxWriter.writeBox(this.mdat);for(let i of this.finalizedChunks)for(let a of i.samples)m(a.data),this.writer.write(a.data),a.data=null}else if(this.fastStart==="fragmented"){let t=this.writer.getPos(),s=Wt(this.trackDatas);this.boxWriter.writeBox(s);let i=this.writer.getPos()-t;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(i)}else{m(this.mdat),m(this.ftypSize!==null);let t=this.boxWriter.offsets.get(this.mdat);m(t!==void 0);let s=this.writer.getPos()-t;this.mdat.size=s,this.mdat.largeSize=s>=2**32,this.boxWriter.patchBox(this.mdat);let i=pe(this.trackDatas,this.creationTime);if(typeof this.fastStart=="object"){this.writer.seek(this.ftypSize),this.boxWriter.writeBox(i);let a=t-this.writer.getPos();this.boxWriter.writeBox(Bt(a))}else this.boxWriter.writeBox(i)}e()}};var ge=class{value;constructor(e){this.value=e}},ce=class{value;constructor(e){this.value=e}},ke=class{value;constructor(e){this.value=e}};var Tt=r=>r<256?1:r<65536?2:r<1<<24?3:r<2**32?4:r<2**40?5:6,xt=r=>r>=-64&&r<64?1:r>=-8192&&r<8192?2:r>=-(1<<20)&&r<1<<20?3:r>=-(1<<27)&&r<1<<27?4:r>=-(2**34)&&r<2**34?5:6,tr=r=>{if(r<127)return 1;if(r<16383)return 2;if(r<(1<<21)-1)return 3;if(r<(1<<28)-1)return 4;if(r<2**35-1)return 5;if(r<2**42-1)return 6;throw new Error("EBML VINT size not supported "+r)};var St=2**15,rr="https://github.com/Vanilagy/webm-muxer",ir=6,sr=5,Ti={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",opus:"A_OPUS",webvtt:"S_TEXT/WEBVTT"},xi={video:1,audio:2,subtitle:17},We=class extends ae{timestampsMustStartAtZero=!1;writer;format;helper=new Uint8Array(8);helperView=new DataView(this.helper.buffer);offsets=new WeakMap;dataOffsets=new WeakMap;trackDatas=[];segment=null;segmentInfo=null;seekHead=null;tracksElement=null;segmentDuration=null;cues=null;currentCluster=null;currentClusterMsTimestamp=null;trackDatasInCurrentCluster=new Set;duration=0;constructor(e,t){super(e),this.writer=e._writer,this.format=t,this.format._options.streamable&&(this.writer.ensureMonotonicity=!0)}writeByte(e){this.helperView.setUint8(0,e),this.writer.write(this.helper.subarray(0,1))}writeFloat32(e){this.helperView.setFloat32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeFloat64(e){this.helperView.setFloat64(0,e,!1),this.writer.write(this.helper)}writeUnsignedInt(e,t=Tt(e)){let s=0;switch(t){case 6:this.helperView.setUint8(s++,e/2**40|0);case 5:this.helperView.setUint8(s++,e/2**32|0);case 4:this.helperView.setUint8(s++,e>>24);case 3:this.helperView.setUint8(s++,e>>16);case 2:this.helperView.setUint8(s++,e>>8);case 1:this.helperView.setUint8(s++,e);break;default:throw new Error("Bad UINT size "+t)}this.writer.write(this.helper.subarray(0,s))}writeSignedInt(e,t=xt(e)){e<0&&(e+=2**(t*8)),this.writeUnsignedInt(e,t)}writeEBMLVarInt(e,t=tr(e)){let s=0;switch(t){case 1:this.helperView.setUint8(s++,128|e);break;case 2:this.helperView.setUint8(s++,64|e>>8),this.helperView.setUint8(s++,e);break;case 3:this.helperView.setUint8(s++,32|e>>16),this.helperView.setUint8(s++,e>>8),this.helperView.setUint8(s++,e);break;case 4:this.helperView.setUint8(s++,16|e>>24),this.helperView.setUint8(s++,e>>16),this.helperView.setUint8(s++,e>>8),this.helperView.setUint8(s++,e);break;case 5:this.helperView.setUint8(s++,8|e/2**32&7),this.helperView.setUint8(s++,e>>24),this.helperView.setUint8(s++,e>>16),this.helperView.setUint8(s++,e>>8),this.helperView.setUint8(s++,e);break;case 6:this.helperView.setUint8(s++,4|e/2**40&3),this.helperView.setUint8(s++,e/2**32|0),this.helperView.setUint8(s++,e>>24),this.helperView.setUint8(s++,e>>16),this.helperView.setUint8(s++,e>>8),this.helperView.setUint8(s++,e);break;default:throw new Error("Bad EBML VINT size "+t)}this.writer.write(this.helper.subarray(0,s))}writeString(e){this.writer.write(new Uint8Array(e.split("").map(t=>t.charCodeAt(0))))}writeEBML(e){if(e!==null){if(e instanceof Uint8Array)this.writer.write(e);else if(Array.isArray(e))for(let t of e)this.writeEBML(t);else if(this.offsets.set(e,this.writer.getPos()),this.writeUnsignedInt(e.id),Array.isArray(e.data)){let t=this.writer.getPos(),s=e.size===-1?1:e.size??4;e.size===-1?this.writeByte(255):this.writer.seek(this.writer.getPos()+s);let i=this.writer.getPos();if(this.dataOffsets.set(e,i),this.writeEBML(e.data),e.size!==-1){let a=this.writer.getPos()-i,n=this.writer.getPos();this.writer.seek(t),this.writeEBMLVarInt(a,s),this.writer.seek(n)}}else if(typeof e.data=="number"){let t=e.size??Tt(e.data);this.writeEBMLVarInt(t),this.writeUnsignedInt(e.data,t)}else if(typeof e.data=="string")this.writeEBMLVarInt(e.data.length),this.writeString(e.data);else if(e.data instanceof Uint8Array)this.writeEBMLVarInt(e.data.byteLength,e.size),this.writer.write(e.data);else if(e.data instanceof ge)this.writeEBMLVarInt(4),this.writeFloat32(e.data.value);else if(e.data instanceof ce)this.writeEBMLVarInt(8),this.writeFloat64(e.data.value);else if(e.data instanceof ke){let t=e.size??xt(e.data.value);this.writeEBMLVarInt(t),this.writeSignedInt(e.data.value,t)}}}beforeTrackAdd(e){if(this.format instanceof J)if(e.type==="video"){if(!["vp8","vp9","av1"].includes(e.source._codec))throw new Error("WebM only supports VP8, VP9 and AV1 as video codecs. Switching to MKV removes this restriction.")}else if(e.type==="audio"){if(!["opus","vorbis"].includes(e.source._codec))throw new Error("WebM only supports Opus and Vorbis as audio codecs. Switching to MKV removes this restriction.")}else if(e.type==="subtitle"){if(e.source._codec!=="webvtt")throw new Error("WebM only supports WebVTT as subtitle codec. Switching to MKV removes this restriction.")}else throw new Error("WebM only supports video, audio and subtitle tracks. Switching to MKV removes this restriction.")}async start(){let e=await this.mutex.acquire();this.writeEBMLHeader(),this.format._options.streamable||this.createSeekHead(),this.createSegmentInfo(),this.createCues(),await this.writer.flush(),e()}writeEBMLHeader(){let e={id:440786851,data:[{id:17030,data:1},{id:17143,data:1},{id:17138,data:4},{id:17139,data:8},{id:17026,data:this.format instanceof J?"webm":"matroska"},{id:17031,data:2},{id:17029,data:2}]};this.writeEBML(e)}createSeekHead(){let e=new Uint8Array([28,83,187,107]),t=new Uint8Array([21,73,169,102]),s=new Uint8Array([22,84,174,107]),i={id:290298740,data:[{id:19899,data:[{id:21419,data:e},{id:21420,size:5,data:0}]},{id:19899,data:[{id:21419,data:t},{id:21420,size:5,data:0}]},{id:19899,data:[{id:21419,data:s},{id:21420,size:5,data:0}]}]};this.seekHead=i}createSegmentInfo(){let e={id:17545,data:new ce(0)};this.segmentDuration=e;let t={id:357149030,data:[{id:2807729,data:1e6},{id:19840,data:rr},{id:22337,data:rr},this.format._options.streamable?null:e]};this.segmentInfo=t}createTracks(){let e={id:374648427,data:[]};this.tracksElement=e;for(let t of this.trackDatas)e.data.push({id:174,data:[{id:215,data:t.track.id},{id:29637,data:t.track.id},{id:131,data:xi[t.type]},{id:134,data:Ti[t.track.source._codec]},t.type==="video"?this.videoSpecificTrackInfo(t):null,t.type==="audio"?this.audioSpecificTrackInfo(t):null,t.type==="subtitle"?this.subtitleSpecificTrackInfo(t):null]})}videoSpecificTrackInfo(e){let t=[e.info.decoderConfig.description?{id:25506,data:Q(e.info.decoderConfig.description)}:null,e.track.metadata.frameRate?{id:2352003,data:1e9/e.track.metadata.frameRate}:null],s=e.info.decoderConfig.colorSpace,i={id:224,data:[{id:176,data:e.info.width},{id:186,data:e.info.height},Re(s)?{id:21936,data:[{id:21937,data:q[s.matrix]},{id:21946,data:j[s.transfer]},{id:21947,data:K[s.primaries]},{id:21945,data:s.fullRange?2:1}]}:null]};return t.push(i),t}audioSpecificTrackInfo(e){return[e.info.decoderConfig.description?{id:25506,data:Q(e.info.decoderConfig.description)}:null,{id:225,data:[{id:181,data:new ge(e.info.sampleRate)},{id:159,data:e.info.numberOfChannels}]}]}subtitleSpecificTrackInfo(e){return[{id:25506,data:O.encode(e.info.config.description)}]}createSegment(){let e={id:408125543,size:this.format._options.streamable?-1:ir,data:[this.format._options.streamable?null:this.seekHead,this.segmentInfo,this.tracksElement]};this.segment=e,this.writeEBML(e)}createCues(){this.cues={id:475249515,data:[]}}get segmentDataOffset(){return m(this.segment),this.dataOffsets.get(this.segment)}getVideoTrackData(e,t){let s=this.trackDatas.find(a=>a.track===e);if(s)return s;De(t),m(t),m(t.decoderConfig),m(t.decoderConfig.codedWidth!==void 0),m(t.decoderConfig.codedHeight!==void 0);let i={track:e,type:"video",info:{width:t.decoderConfig.codedWidth,height:t.decoderConfig.codedHeight,decoderConfig:t.decoderConfig},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(i),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),i}getAudioTrackData(e,t){let s=this.trackDatas.find(a=>a.track===e);if(s)return s;Ue(t),m(t),m(t.decoderConfig);let i={track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(i),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),i}getSubtitleTrackData(e,t){let s=this.trackDatas.find(a=>a.track===e);if(s)return s;Be(t),m(t),m(t.config);let i={track:e,type:"subtitle",info:{config:t.config},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(i),this.trackDatas.sort((a,n)=>a.track.id-n.track.id),i}async addEncodedVideoChunk(e,t,s){let i=await this.mutex.acquire();try{let a=this.getVideoTrackData(e,s),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=t.type==="key",o=this.validateAndNormalizeTimestamp(a.track,t.timestamp,c),u=this.createInternalChunk(n,o,(t.duration??0)/1e6,t.type);e.source._codec==="vp9"&&this.fixVP9ColorSpace(a,u),a.chunkQueue.push(u),await this.interleaveChunks()}finally{i()}}async addEncodedAudioChunk(e,t,s){let i=await this.mutex.acquire();try{let a=this.getAudioTrackData(e,s),n=new Uint8Array(t.byteLength);t.copyTo(n);let c=t.type,o=c==="key",u=this.validateAndNormalizeTimestamp(a.track,t.timestamp,o),d=this.createInternalChunk(n,u,(t.duration??0)/1e6,c);a.chunkQueue.push(d),await this.interleaveChunks()}finally{i()}}async addSubtitleCue(e,t,s){let i=await this.mutex.acquire();try{let a=this.getSubtitleTrackData(e,s),n=this.validateAndNormalizeTimestamp(a.track,1e6*t.timestamp,!0),c=t.text,o=Math.floor(n*1e3);se.lastIndex=0,c=c.replace(se,g=>{let b=Oe(g.slice(1,-1))-o;return`<${Ee(b)}>`});let u=O.encode(c),d=`${t.settings??""}
${t.identifier??""}
${t.notes??""}`,l=this.createInternalChunk(u,n,t.duration,"key",d.trim()?O.encode(d):null);a.chunkQueue.push(l),await this.interleaveChunks()}finally{i()}}async interleaveChunks(){for(let e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return;e:for(;;){let e=null,t=1/0;for(let i of this.trackDatas){if(i.chunkQueue.length===0&&!i.track.source._closed)break e;i.chunkQueue.length>0&&i.chunkQueue[0].timestamp<t&&(e=i,t=i.chunkQueue[0].timestamp)}if(!e)break;let s=e.chunkQueue.shift();this.writeBlock(e,s)}await this.writer.flush()}fixVP9ColorSpace(e,t){if(t.type!=="key"||!e.info.decoderConfig.colorSpace||!e.info.decoderConfig.colorSpace.matrix)return;let s=0;if($(t.data,0,2)!==2)return;s+=2;let i=($(t.data,s+1,s+2)<<1)+$(t.data,s+0,s+1);s+=2,i===3&&s++;let a=$(t.data,s+0,s+1);if(s++,a)return;let n=$(t.data,s+0,s+1);if(s++,n!==0)return;s+=2;let c=$(t.data,s+0,s+24);if(s+=24,c!==4817730)return;i>=2&&s++;let o={rgb:7,bt709:2,bt470bg:1,smpte170m:3}[e.info.decoderConfig.colorSpace.matrix];_t(t.data,s+0,s+3,o)}createInternalChunk(e,t,s,i,a=null){return{data:e,type:i,timestamp:t,duration:s,additions:a}}writeBlock(e,t){this.segment||(this.createTracks(),this.createSegment());let s=Math.floor(1e3*t.timestamp),i=this.trackDatas.every(d=>{if(d.track.source._closed)return!0;if(e===d)return t.type==="key";let l=d.chunkQueue[0];return l&&l.type==="key"});(!this.currentCluster||i&&s-this.currentClusterMsTimestamp>=1e3)&&this.createNewCluster(s);let a=s-this.currentClusterMsTimestamp;if(a<0)return;if(a>=St)throw new Error(`Current Matroska cluster exceeded its maximum allowed length of ${St} milliseconds. In order to produce a correct WebM file, you must pass in a key frame at least every ${St} milliseconds.`);let c=new Uint8Array(4),o=new DataView(c.buffer);o.setUint8(0,128|e.track.id),o.setInt16(1,a,!1);let u=Math.floor(1e3*t.duration);if(u===0&&!t.additions){o.setUint8(3,+(t.type==="key")<<7);let d={id:163,data:[c,t.data]};this.writeEBML(d)}else{let d={id:160,data:[{id:161,data:[c,t.data]},t.type==="delta"?{id:251,data:new ke(e.lastWrittenMsTimestamp-s)}:null,t.additions?{id:30113,data:[{id:166,data:[{id:165,data:t.additions},{id:238,data:1}]}]}:null,u>0?{id:155,data:u}:null]};this.writeEBML(d)}this.duration=Math.max(this.duration,s+u),e.lastWrittenMsTimestamp=s,this.trackDatasInCurrentCluster.add(e)}createNewCluster(e){this.currentCluster&&!this.format._options.streamable&&this.finalizeCurrentCluster(),this.currentCluster={id:524531317,size:this.format._options.streamable?-1:sr,data:[{id:231,data:e}]},this.writeEBML(this.currentCluster),this.currentClusterMsTimestamp=e,this.trackDatasInCurrentCluster.clear()}finalizeCurrentCluster(){m(this.currentCluster);let e=this.writer.getPos()-this.dataOffsets.get(this.currentCluster),t=this.writer.getPos();this.writer.seek(this.offsets.get(this.currentCluster)+4),this.writeEBMLVarInt(e,sr),this.writer.seek(t);let s=this.offsets.get(this.currentCluster)-this.segmentDataOffset;m(this.cues),this.cues.data.push({id:187,data:[{id:179,data:this.currentClusterMsTimestamp},...[...this.trackDatasInCurrentCluster].map(i=>({id:183,data:[{id:247,data:i.track.id},{id:241,data:s}]}))]})}async onTrackClose(){let e=await this.mutex.acquire();await this.interleaveChunks(),e()}async finalize(){let e=await this.mutex.acquire();this.segment||(this.createTracks(),this.createSegment());for(let t of this.trackDatas)for(;t.chunkQueue.length>0;)this.writeBlock(t,t.chunkQueue.shift());if(!this.format._options.streamable&&this.currentCluster&&this.finalizeCurrentCluster(),m(this.cues),this.writeEBML(this.cues),!this.format._options.streamable){let t=this.writer.getPos(),s=this.writer.getPos()-this.segmentDataOffset;this.writer.seek(this.offsets.get(this.segment)+4),this.writeEBMLVarInt(s,ir),this.segmentDuration.data=new ce(this.duration),this.writer.seek(this.offsets.get(this.segmentDuration)),this.writeEBML(this.segmentDuration),this.seekHead.data[0].data[1].data=this.offsets.get(this.cues)-this.segmentDataOffset,this.seekHead.data[1].data[1].data=this.offsets.get(this.segmentInfo)-this.segmentDataOffset,this.seekHead.data[2].data[1].data=this.offsets.get(this.tracksElement)-this.segmentDataOffset,this.writer.seek(this.offsets.get(this.seekHead)),this.writeEBML(this.seekHead),this.writer.seek(t)}e()}};var W=class{},He=class extends W{_options;constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","fragmented"].includes(e.fastStart))throw new TypeError('options.fastStart, when provided, must be false, "in-memory", or "fragmented".');super(),this._options=e}_createMuxer(e){return new Ne(e,this)}},Te=class extends W{_options;constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.streamable!==void 0&&typeof e.streamable!="boolean")throw new TypeError("options.streamable, when provided, must be a boolean.");super(),this._options=e}_createMuxer(e){return new We(e,this)}},J=class extends Te{};var ee=class{_connectedTrack=null;_closed=!1;_offsetTimestamps=!1;_ensureValidDigest(){if(!this._connectedTrack)throw new Error("Cannot call digest without connecting the source to an output track.");if(!this._connectedTrack.output._started)throw new Error("Cannot call digest before output has been started.");if(this._connectedTrack.output._finalizing)throw new Error("Cannot call digest after output has started finalizing.");if(this._closed)throw new Error("Cannot call digest after source has been closed.")}_start(){}async _flush(){}close(){if(this._closed)throw new Error("Source already closed.");if(!this._connectedTrack)throw new Error("Cannot call close without connecting the source to an output track.");if(!this._connectedTrack.output._started)throw new Error("Cannot call close before output has been started.");this._closed=!0,!this._connectedTrack.output._finalizing&&this._connectedTrack.output._muxer.onTrackClose(this._connectedTrack)}},z=class extends ee{_connectedTrack=null;_codec;constructor(e){if(super(),!Y.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${Y.join(", ")}.`);this._codec=e}},Le=class extends z{constructor(e){super(e)}digest(e,t){if(!(e instanceof EncodedVideoChunk))throw new TypeError("chunk must be an EncodedVideoChunk.");return this._ensureValidDigest(),this._connectedTrack.output._muxer.addEncodedVideoChunk(this._connectedTrack,e,t)}},Si=5,Ci=r=>{if(!r||typeof r!="object")throw new TypeError("Codec config must be an object.");if(!Y.includes(r.codec))throw new TypeError(`Invalid video codec '${r.codec}'. Must be one of: ${Y.join(", ")}.`);if(!Number.isInteger(r.bitrate)||r.bitrate<=0)throw new TypeError("config.bitrate must be a positive integer.");if(r.latencyMode!==void 0&&!["quality","realtime"].includes(r.latencyMode))throw new TypeError("config.latencyMode, when provided, must be 'quality' or 'realtime'.")},xe=class{constructor(e,t){this.source=e;this.codecConfig=t;Ci(t)}encoder=null;muxer=null;lastMultipleOfKeyFrameInterval=-1;lastWidth=null;lastHeight=null;async digest(e){if(this.source._ensureValidDigest(),this.lastWidth!==null&&this.lastHeight!==null){if(e.codedWidth!==this.lastWidth||e.codedHeight!==this.lastHeight)throw new Error(`Video frame size must remain constant. Expected ${this.lastWidth}x${this.lastHeight}, got ${e.codedWidth}x${e.codedHeight}.`)}else this.lastWidth=e.codedWidth,this.lastHeight=e.codedHeight;this.ensureEncoder(e),m(this.encoder);let t=Math.floor(e.timestamp/1e6/Si);this.encoder.encode(e,{keyFrame:t!==this.lastMultipleOfKeyFrameInterval}),this.lastMultipleOfKeyFrameInterval=t,this.encoder.encodeQueueSize>=4&&await new Promise(s=>this.encoder.addEventListener("dequeue",s,{once:!0})),await this.muxer.mutex.currentPromise}ensureEncoder(e){this.encoder||(this.encoder=new VideoEncoder({output:(t,s)=>void this.muxer.addEncodedVideoChunk(this.source._connectedTrack,t,s),error:t=>console.error("Video encode error:",t)}),this.encoder.configure({codec:Xt(this.codecConfig.codec,e.codedWidth,e.codedHeight,this.codecConfig.bitrate),width:e.codedWidth,height:e.codedHeight,bitrate:this.codecConfig.bitrate,framerate:this.source._connectedTrack?.metadata.frameRate,latencyMode:this.codecConfig.latencyMode,...Jt(this.codecConfig.codec)}),m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer)}async flush(){this.encoder&&(await this.encoder.flush(),this.encoder.close())}},$e=class extends z{_encoder;constructor(e){super(e.codec),this._encoder=new xe(this,e)}digest(e){if(!(e instanceof VideoFrame))throw new TypeError("videoFrame must be a VideoFrame.");return this._encoder.digest(e)}_flush(){return this._encoder.flush()}},Qe=class extends z{_encoder;_canvas;constructor(e,t){if(!(e instanceof HTMLCanvasElement))throw new TypeError("canvas must be an HTMLCanvasElement.");super(t.codec),this._encoder=new xe(this,t),this._canvas=e}digest(e,t=0){if(!Number.isFinite(e)||e<0)throw new TypeError("timestamp must be a non-negative number.");if(!Number.isFinite(t)||t<0)throw new TypeError("duration must be a non-negative number.");let s=new VideoFrame(this._canvas,{timestamp:Math.round(1e6*e),duration:Math.round(1e6*t),alpha:"discard"}),i=this._encoder.digest(s);return s.close(),i}_flush(){return this._encoder.flush()}},Ke=class extends z{_encoder;_abortController=null;_track;_offsetTimestamps=!0;constructor(e,t){if(!(e instanceof MediaStreamTrack)||e.kind!=="video")throw new TypeError("track must be a video MediaStreamTrack.");t={...t,latencyMode:"realtime"},super(t.codec),this._encoder=new xe(this,t),this._track=e}_start(){this._abortController=new AbortController;let e=new MediaStreamTrackProcessor({track:this._track}),t=new WritableStream({write:s=>{this._encoder.digest(s),s.close()}});e.readable.pipeTo(t,{signal:this._abortController.signal}).catch(s=>{s instanceof DOMException&&s.name==="AbortError"||console.error("Pipe error:",s)})}async _flush(){this._abortController&&(this._abortController.abort(),this._abortController=null),await this._encoder.flush()}},P=class extends ee{_connectedTrack=null;_codec;constructor(e){if(super(),!Z.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${Z.join(", ")}.`);this._codec=e}},je=class extends P{constructor(e){super(e)}digest(e,t){if(!(e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedAudioChunk.");return this._ensureValidDigest(),this._connectedTrack.output._muxer.addEncodedAudioChunk(this._connectedTrack,e,t)}},wi=r=>{if(!r||typeof r!="object")throw new TypeError("Codec config must be an object.");if(!Z.includes(r.codec))throw new TypeError(`Invalid audio codec '${r.codec}'. Must be one of: ${Z.join(", ")}.`);if(!Number.isInteger(r.bitrate)||r.bitrate<=0)throw new TypeError("config.bitrate must be a positive integer.")},Se=class{constructor(e,t){this.source=e;this.codecConfig=t;wi(t)}encoder=null;muxer=null;lastNumberOfChannels=null;lastSampleRate=null;async digest(e){if(this.source._ensureValidDigest(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;this.ensureEncoder(e),m(this.encoder),this.encoder.encode(e),this.encoder.encodeQueueSize>=4&&await new Promise(t=>this.encoder.addEventListener("dequeue",t,{once:!0})),await this.muxer.mutex.currentPromise}ensureEncoder(e){this.encoder||(this.encoder=new AudioEncoder({output:(t,s)=>void this.muxer.addEncodedAudioChunk(this.source._connectedTrack,t,s),error:t=>console.error("Audio encode error:",t)}),this.encoder.configure({codec:Yt(this.codecConfig.codec,e.numberOfChannels,e.sampleRate),numberOfChannels:e.numberOfChannels,sampleRate:e.sampleRate,bitrate:this.codecConfig.bitrate,...er(this.codecConfig.codec)}),m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer)}async flush(){this.encoder&&(await this.encoder.flush(),this.encoder.close())}},qe=class extends P{_encoder;constructor(e){super(e.codec),this._encoder=new Se(this,e)}digest(e){if(!(e instanceof AudioData))throw new TypeError("audioData must be an AudioData.");return this._encoder.digest(e)}_flush(){return this._encoder.flush()}},Xe=class extends P{_encoder;_accumulatedFrameCount=0;constructor(e){super(e.codec),this._encoder=new Se(this,e)}digest(e){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");let t=e.numberOfChannels,s=e.sampleRate,i=e.length,a=new Float32Array(t*i);for(let o=0;o<t;o++){let u=e.getChannelData(o);a.set(u,o*i)}let n=new AudioData({format:"f32-planar",sampleRate:s,numberOfFrames:i,numberOfChannels:t,timestamp:Math.round(1e6*this._accumulatedFrameCount/s),data:a}),c=this._encoder.digest(n);return n.close(),this._accumulatedFrameCount+=i,c}_flush(){return this._encoder.flush()}},Ge=class extends P{_encoder;_abortController=null;_track;_offsetTimestamps=!0;constructor(e,t){if(!(e instanceof MediaStreamTrack)||e.kind!=="audio")throw new TypeError("track must be an audio MediaStreamTrack.");super(t.codec),this._encoder=new Se(this,t),this._track=e}_start(){this._abortController=new AbortController;let e=new MediaStreamTrackProcessor({track:this._track}),t=new WritableStream({write:s=>{this._encoder.digest(s),s.close()}});e.readable.pipeTo(t,{signal:this._abortController.signal}).catch(s=>{s instanceof DOMException&&s.name==="AbortError"||console.error("Pipe error:",s)})}async _flush(){this._abortController&&(this._abortController.abort(),this._abortController=null),await this._encoder.flush()}},te=class extends ee{_connectedTrack=null;_codec;constructor(e){if(super(),!be.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${be.join(", ")}.`);this._codec=e}},Ye=class extends te{_parser;constructor(e){super(e),this._parser=new Ae({codec:e,output:(t,s)=>this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack,t,s),error:t=>console.error("Subtitle parse error:",t)})}digest(e){if(typeof e!="string")throw new TypeError("text must be a string.");return this._ensureValidDigest(),this._parser.parse(e),this._connectedTrack.output._muxer.mutex.currentPromise}};var Ze=class{_muxer;_writer;_tracks=[];_started=!1;_finalizing=!1;_mutex=new U;constructor(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof W))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof N))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,t={}){if(!(e instanceof z))throw new TypeError("source must be a VideoSource.");if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(typeof t.rotation=="number"&&![0,90,180,270].includes(t.rotation))throw new TypeError(`Invalid video rotation: ${t.rotation}. Has to be 0, 90, 180 or 270.`);if(Array.isArray(t.rotation)&&(t.rotation.length!==9||t.rotation.some(s=>!Number.isFinite(s))))throw new TypeError(`Invalid video transformation matrix: ${t.rotation.join()}`);if(t.frameRate!==void 0&&(!Number.isInteger(t.frameRate)||t.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${t.frameRate}. Must be a positive integer.`);this._addTrack("video",e,t)}addAudioTrack(e,t={}){if(!(e instanceof P))throw new TypeError("source must be an AudioSource.");if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");this._addTrack("audio",e,t)}addSubtitleTrack(e,t={}){if(!(e instanceof te))throw new TypeError("source must be a SubtitleSource.");if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");this._addTrack("subtitle",e,t)}_addTrack(e,t,s){if(this._started)throw new Error("Cannot add track after output has started.");if(t._connectedTrack)throw new Error("Source is already used for a track.");let i={id:this._tracks.length+1,output:this,type:e,source:t,metadata:s};this._muxer.beforeTrackAdd(i),this._tracks.push(i),t._connectedTrack=i}async start(){if(this._started)throw new Error("Output already started.");this._started=!0,this._writer.start();let e=await this._mutex.acquire();await this._muxer.start();for(let t of this._tracks)t.source._start();e()}async finalize(){if(!this._started)throw new Error("Cannot finalize before starting.");if(this._finalizing)throw new Error("Cannot call finalize twice.");this._finalizing=!0;let e=await this._mutex.acquire(),t=this._tracks.map(s=>s.source._flush());await Promise.all(t),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),e()}};var ue=class{_sizePromise=null;_getSize(){return this._sizePromise??=this._retrieveSize()}},Je=class extends ue{constructor(t){super();this.buffer=t}async _read(t,s){return new Uint8Array(this.buffer,t,s-t)}async _retrieveSize(){return this.buffer.byteLength}},et=class extends ue{constructor(t){super();this.blob=t}async _read(t,s){let a=await this.blob.slice(t,s).arrayBuffer();return new Uint8Array(a)}async _retrieveSize(){return this.blob.size}};var me=class{input;constructor(e){this.input=e}};var tt=class{_backing;constructor(e){this._backing=e}isVideoTrack(){return this instanceof Ce}isAudioTrack(){return this instanceof we}getDuration(){return this._backing.getDuration()}},Ce=class extends tt{_backing;constructor(e){super(e),this._backing=e}getCodec(){return this._backing.getCodec()}getWidth(){return this._backing.getWidth()}getHeight(){return this._backing.getHeight()}getRotation(){return this._backing.getRotation()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecMimeType(){return(await this.getDecoderConfig()).codec}},we=class extends tt{_backing;constructor(e){super(e),this._backing=e}getCodec(){return this._backing.getCodec()}getNumberOfChannels(){return this._backing.getNumberOfChannels()}getSampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecMimeType(){return(await this.getDecoderConfig()).codec}};var de=class{constructor(e,t=1/0){this.source=e;this.maxStorableBytes=t}loadedSegments=[];loadingSegments=[];sourceSizePromise=null;nextAge=0;totalStoredBytes=0;async loadRange(e,t){t=Math.min(t,await this.source._getSize());let s=this.loadingSegments.find(o=>o.start<=e&&o.end>=t);if(s){await s.promise;return}if(this.loadedSegments.some(o=>o.start<=e&&o.end>=t))return;let a=this.source._read(e,t),n={start:e,end:t,promise:a};this.loadingSegments.push(n);let c=await a;Ft(this.loadingSegments,n),this.insertIntoLoadedSegments(e,c)}insertIntoLoadedSegments(e,t){let s={start:e,end:e+t.byteLength,bytes:t,view:new DataView(t.buffer),age:this.nextAge++},i=I(this.loadedSegments,e,a=>a.start);(i===-1||this.loadedSegments[i].start<s.start)&&i++,this.loadedSegments.splice(i,0,s),this.totalStoredBytes+=t.byteLength;for(let a=i+1;a<this.loadedSegments.length;a++){let n=this.loadedSegments[a];if(n.start>=s.end)break;s.start<=n.start&&n.end<=s.end&&(this.loadedSegments.splice(a,1),a--)}for(;this.totalStoredBytes>this.maxStorableBytes&&this.loadedSegments.length>1;){let a=null,n=-1;for(let c=0;c<this.loadedSegments.length;c++){let o=this.loadedSegments[c];(!a||o.age<a.age)&&(a=o,n=c)}m(a),this.totalStoredBytes-=a.bytes.byteLength,this.loadedSegments.splice(n,1)}}getViewAndOffset(e,t){let s=I(this.loadedSegments,e,a=>a.start),i=null;if(s!==-1)for(let a=s;a<this.loadedSegments.length;a++){let n=this.loadedSegments[a];if(n.start>e)break;if(t<=n.end){i=n;break}}if(!i)throw new Error(`No segment loaded for range [${e}, ${t}).`);return i.age=this.nextAge++,{view:i.view,offset:i.bytes.byteOffset+e-i.start}}forgetRange(e,t){if(t<=e)return;let s=I(this.loadedSegments,e,a=>a.start);if(s===-1)return;let i=this.loadedSegments[s];i.start!==e||i.end!==t||(this.loadedSegments.splice(s,1),this.totalStoredBytes-=i.bytes.byteLength)}};var re=class{constructor(e){this.reader=e}pos=0;readRange(e,t){let{view:s,offset:i}=this.reader.getViewAndOffset(e,t);return new Uint8Array(s.buffer,i,t-e)}readU8(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+1);return this.pos++,e.getUint8(t)}readU16(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+2);return this.pos+=2,e.getUint16(t,!1)}readU24(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+3);this.pos+=3;let s=e.getUint16(t,!1),i=e.getUint8(t+2);return s*256+i}readS32(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getInt32(t,!1)}readU32(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getUint32(t,!1)}readI32(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+4);return this.pos+=4,e.getInt32(t,!1)}readU64(){let e=this.readU32(),t=this.readU32();return e*4294967296+t}readF64(){let{view:e,offset:t}=this.reader.getViewAndOffset(this.pos,this.pos+8);return this.pos+=8,e.getFloat64(t,!1)}readFixed_16_16(){return this.readS32()/65536}readFixed_2_30(){return this.readS32()/1073741824}readAscii(e){let{view:t,offset:s}=this.reader.getViewAndOffset(this.pos,this.pos+e);this.pos+=e;let i="";for(let a=0;a<e;a++)i+=String.fromCharCode(t.getUint8(s+a));return i}readIsomVariableInteger(){let e=0;for(let t=0;t<4;t++){e<<=7;let s=this.readU8();if(e|=s&127,!(s&128))break}return e}readBoxHeader(){let e=this.readU32(),t=this.readAscii(4),s=8;return e===1&&(e=this.readU64(),s=16),{name:t,totalSize:e,headerSize:s,contentSize:e-s}}};var yi=[B(0),B(90),B(180),B(270)],rt=class extends me{isobmffReader;currentTrack=null;tracks=[];metadataPromise=null;movieTimescale=-1;movieDurationInTimescale=-1;isFragmented=!1;fragmentTrackDefaults=[];fragments=[];currentFragment=null;fragmentLookupMutex=new U;chunkReader;constructor(e){super(e),this.isobmffReader=new re(e._mainReader),this.chunkReader=new re(new de(e._source,64*2**20))}async getDuration(){if(await this.readMetadata(),this.movieDurationInTimescale===-1)throw new Error("Could not read movie duration.");return this.movieDurationInTimescale/this.movieTimescale}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();let e="video/mp4";if(this.tracks.length>0){let t=await Promise.all(this.tracks.map(i=>i.inputTrack.getCodecMimeType())),s=[...new Set(t)];e+=`; codecs="${s.join(", ")}"`}return e}readMetadata(){return this.metadataPromise??=(async()=>{let e=await this.isobmffReader.reader.source._getSize();for(;this.isobmffReader.pos<e;){await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+16);let t=this.isobmffReader.pos,s=this.isobmffReader.readBoxHeader();if(s.name==="moov"){await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+s.contentSize),this.readContiguousBoxes(s.contentSize);break}this.isobmffReader.pos=t+s.totalSize}if(this.isFragmented){await this.isobmffReader.reader.loadRange(e-4,e),this.isobmffReader.pos=e-4;let t=this.isobmffReader.readU32(),s=e-t;if(s>=0&&s<e){await this.isobmffReader.reader.loadRange(s,e),this.isobmffReader.pos=s;let i=this.isobmffReader.readBoxHeader();i.name==="mfra"&&this.readContiguousBoxes(i.contentSize)}}})()}getSampleTableForTrack(e){if(e.sampleTable)return e.sampleTable;let t={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:[]};e.sampleTable=t,this.isobmffReader.pos=e.sampleTableOffset,this.currentTrack=e,this.traverseBox(),this.currentTrack=null;for(let s of t.sampleTimingEntries)for(let i=0;i<s.count;i++)t.presentationTimestamps.push({presentationTimestamp:s.startDecodeTimestamp+i*s.delta,sampleIndex:s.startIndex+i});for(let s of t.sampleCompositionTimeOffsets)for(let i=0;i<s.count;i++){let a=s.startIndex+i,n=t.presentationTimestamps[a];n&&(n.presentationTimestamp+=s.offset)}return t.presentationTimestamps.sort((s,i)=>s.presentationTimestamp-i.presentationTimestamp),e.sampleTable}async readFragment(){let e=this.isobmffReader.pos;await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+16);let t=this.isobmffReader.readBoxHeader();m(t.name==="moof"),await this.isobmffReader.reader.loadRange(e,e+t.totalSize),this.isobmffReader.pos=e,this.traverseBox();let s=D(this.fragments,e,a=>a.moofOffset);m(s!==-1);let i=this.fragments[s];m(i.moofOffset===e),this.isobmffReader.reader.forgetRange(e,e+t.totalSize);for(let[a,n]of i.trackData){if(n.startTimestampIsFinal)continue;let c=this.tracks.find(l=>l.id===a);this.isobmffReader.pos=0;let o=null,u=null,d=I(c.fragments,e-1,l=>l.moofOffset);for(d!==-1&&(o=c.fragments[d],u=o,this.isobmffReader.pos=o.moofOffset+o.moofSize);this.isobmffReader.pos<e;){if(o?.nextFragment)o=o.nextFragment,this.isobmffReader.pos=o.moofOffset+o.moofSize;else{await this.isobmffReader.reader.loadRange(this.isobmffReader.pos,this.isobmffReader.pos+16);let l=this.isobmffReader.pos,g=this.isobmffReader.readBoxHeader();if(g.name==="moof"){let h=D(this.fragments,l,b=>b.moofOffset);if(h===-1){this.isobmffReader.pos=l;let b=await this.readFragment();o&&(o.nextFragment=b),o=b}else{let b=this.fragments[h];o&&(o.nextFragment=b),o=b}}this.isobmffReader.pos=l+g.totalSize}o&&o.trackData.has(a)&&(u=o)}if(u){let l=u.trackData.get(a);m(l.startTimestampIsFinal),nr(n,l.endTimestamp)}n.startTimestampIsFinal=!0}return i}readContiguousBoxes(e){let t=this.isobmffReader.pos;for(;this.isobmffReader.pos-t<e;)this.traverseBox()}traverseBox(){let e=this.isobmffReader.pos,t=this.isobmffReader.readBoxHeader(),s=e+t.totalSize;switch(t.name){case"mdia":case"minf":case"dinf":case"mfra":this.readContiguousBoxes(t.contentSize);break;case"mvhd":{let i=this.isobmffReader.readU8();this.isobmffReader.pos+=3,i===1?(this.isobmffReader.pos+=16,this.movieTimescale=this.isobmffReader.readU32(),this.movieDurationInTimescale=this.isobmffReader.readU64()):(this.isobmffReader.pos+=8,this.movieTimescale=this.isobmffReader.readU32(),this.movieDurationInTimescale=this.isobmffReader.readU32())}break;case"trak":{let i={id:-1,demuxer:this,inputTrack:null,info:null,timescale:-1,durationInTimescale:-1,rotation:0,sampleTableOffset:-1,sampleTable:null,fragmentLookupTable:null,currentFragmentState:null,fragments:[]};if(this.currentTrack=i,this.readContiguousBoxes(t.contentSize),i.id!==-1&&i.timescale!==-1&&i.info!==null){if(i.info.type==="video"&&i.info.codec!==null){let a=i;i.inputTrack=new Ce(new Ct(a)),this.tracks.push(i)}else if(i.info.type==="audio"&&i.info.codec!==null){let a=i;i.inputTrack=new we(new wt(a)),this.tracks.push(i)}}this.currentTrack=null}break;case"tkhd":{let i=this.currentTrack;m(i);let a=this.isobmffReader.readU8();if(!((this.isobmffReader.readU24()&1)!==0))break;if(a===0)this.isobmffReader.pos+=8,i.id=this.isobmffReader.readU32(),this.isobmffReader.pos+=8;else if(a===1)this.isobmffReader.pos+=16,i.id=this.isobmffReader.readU32(),this.isobmffReader.pos+=12;else throw new Error(`Incorrect track header version ${a}.`);this.isobmffReader.pos+=2*4+2+2+2+2;let o=[];o.push(this.isobmffReader.readFixed_16_16(),this.isobmffReader.readFixed_16_16()),this.isobmffReader.pos+=4,o.push(this.isobmffReader.readFixed_16_16(),this.isobmffReader.readFixed_16_16());let u=yi.findIndex(d=>d.every((l,g)=>l===o[g]));u===-1?i.rotation=0:i.rotation=90*u}break;case"mdhd":{let i=this.currentTrack;m(i);let a=this.isobmffReader.readU8();this.isobmffReader.pos+=3,a===0?(this.isobmffReader.pos+=8,i.timescale=this.isobmffReader.readU32(),i.durationInTimescale=this.isobmffReader.readU32()):a===1&&(this.isobmffReader.pos+=16,i.timescale=this.isobmffReader.readU32(),i.durationInTimescale=this.isobmffReader.readU64())}break;case"hdlr":{let i=this.currentTrack;m(i),this.isobmffReader.pos+=8;let a=this.isobmffReader.readAscii(4);a==="vide"?i.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null}:a==="soun"&&(i.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null})}break;case"stbl":{let i=this.currentTrack;m(i),i.sampleTableOffset=e,this.readContiguousBoxes(t.contentSize)}break;case"stsd":{let i=this.currentTrack;if(m(i),i.info===null||i.sampleTable)break;let a=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let n=this.isobmffReader.readU32();for(let c=0;c<n;c++){let o=this.isobmffReader.readBoxHeader();if(i.info.type==="video"){if(o.name==="avc1")i.info.codec="avc";else if(o.name==="hvc1"||o.name==="hev1")i.info.codec="hevc";else{console.warn(`Unsupported video sample entry type ${o.name}.`);break}this.isobmffReader.pos+=6*1+2+2+2+3*4,i.info.width=this.isobmffReader.readU16(),i.info.height=this.isobmffReader.readU16(),this.isobmffReader.pos+=50,this.readContiguousBoxes(e+o.totalSize-this.isobmffReader.pos)}else{if(o.name==="mp4a")i.info.codec="aac";else if(o.name.toLowerCase()==="opus")i.info.codec="opus";else{console.warn(`Unsupported audio sample entry type ${o.name}.`);break}this.isobmffReader.pos+=6*1+2;let u=this.isobmffReader.readU16();this.isobmffReader.pos+=3*2;let d=this.isobmffReader.readU16();this.isobmffReader.pos+=6;let l=this.isobmffReader.readU32()/65536;if(a===0&&u>0){if(u===1)this.isobmffReader.pos+=4*4;else if(u===2){this.isobmffReader.pos+=4,l=this.isobmffReader.readF64(),d=this.isobmffReader.readU32(),this.isobmffReader.pos+=4;let g=this.isobmffReader.readU32(),h=this.isobmffReader.readU32(),b=this.isobmffReader.readU32(),p=this.isobmffReader.readU32()}}i.info.numberOfChannels=d,i.info.sampleRate=l,this.readContiguousBoxes(e+o.totalSize-this.isobmffReader.pos)}}}break;case"avcC":{let i=this.currentTrack;m(i&&i.info),i.info.codecDescription=this.isobmffReader.readRange(this.isobmffReader.pos,this.isobmffReader.pos+t.contentSize)}break;case"hvcC":{let i=this.currentTrack;m(i&&i.info),i.info.codecDescription=this.isobmffReader.readRange(this.isobmffReader.pos,this.isobmffReader.pos+t.contentSize)}break;case"colr":{let i=this.currentTrack;if(m(i&&i.info?.type==="video"),this.isobmffReader.readAscii(4)!=="nclx")break;let n=this.isobmffReader.readU16(),c=this.isobmffReader.readU16(),o=this.isobmffReader.readU16(),u=!!(this.isobmffReader.readU8()&128);i.info.colorSpace={primaries:Rt[n],transfer:At[c],matrix:Ot[o],fullRange:u}}break;case"wave":t.totalSize>8&&this.readContiguousBoxes(t.contentSize);break;case"esds":{let i=this.currentTrack;m(i&&i.info),this.isobmffReader.pos+=4;let a=this.isobmffReader.readU8();m(a===3),this.isobmffReader.readIsomVariableInteger(),this.isobmffReader.pos+=2;let n=this.isobmffReader.readU8(),c=(n&128)!==0,o=(n&64)!==0,u=(n&32)!==0;if(c&&(this.isobmffReader.pos+=2),o){let b=this.isobmffReader.readU8();this.isobmffReader.pos+=b}u&&(this.isobmffReader.pos+=2);let d=this.isobmffReader.readU8();m(d===4),this.isobmffReader.readIsomVariableInteger();let l=this.isobmffReader.readU8();m(l===64),this.isobmffReader.pos+=12;let g=this.isobmffReader.readU8();m(g===5);let h=this.isobmffReader.readIsomVariableInteger();i.info.codecDescription=this.isobmffReader.readRange(this.isobmffReader.pos,this.isobmffReader.pos+h)}break;case"stts":{let i=this.currentTrack;if(m(i),!i.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32(),n=0,c=0;for(let o=0;o<a;o++){let u=this.isobmffReader.readU32(),d=this.isobmffReader.readU32();i.sampleTable.sampleTimingEntries.push({startIndex:n,startDecodeTimestamp:c,count:u,delta:d}),n+=u,c+=u*d}}break;case"ctts":{let i=this.currentTrack;if(m(i),!i.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32(),n=0;for(let c=0;c<a;c++){let o=this.isobmffReader.readU32(),u=this.isobmffReader.readI32();i.sampleTable.sampleCompositionTimeOffsets.push({startIndex:n,count:o,offset:u}),n+=o}}break;case"stsz":{let i=this.currentTrack;if(m(i),!i.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32(),n=this.isobmffReader.readU32();if(a===0)for(let c=0;c<n;c++){let o=this.isobmffReader.readU32();i.sampleTable.sampleSizes.push(o)}else i.sampleTable.sampleSizes.push(a)}break;case"stz2":throw new Error("Unsupported.");case"stss":{let i=this.currentTrack;if(m(i),!i.sampleTable)break;this.isobmffReader.pos+=4,i.sampleTable.keySampleIndices=[];let a=this.isobmffReader.readU32();for(let n=0;n<a;n++){let c=this.isobmffReader.readU32()-1;i.sampleTable.keySampleIndices.push(c)}}break;case"stsc":{let i=this.currentTrack;if(m(i),!i.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32();for(let c=0;c<a;c++){let o=this.isobmffReader.readU32()-1,u=this.isobmffReader.readU32(),d=this.isobmffReader.readU32();i.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:o,samplesPerChunk:u,sampleDescriptionIndex:d})}let n=0;for(let c=0;c<i.sampleTable.sampleToChunk.length;c++)if(i.sampleTable.sampleToChunk[c].startSampleIndex=n,c<i.sampleTable.sampleToChunk.length-1){let u=i.sampleTable.sampleToChunk[c+1].startChunkIndex-i.sampleTable.sampleToChunk[c].startChunkIndex;n+=u*i.sampleTable.sampleToChunk[c].samplesPerChunk}}break;case"stco":{let i=this.currentTrack;if(m(i),!i.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32();for(let n=0;n<a;n++){let c=this.isobmffReader.readU32();i.sampleTable.chunkOffsets.push(c)}}break;case"co64":{let i=this.currentTrack;if(m(i),!i.sampleTable)break;this.isobmffReader.pos+=4;let a=this.isobmffReader.readU32();for(let n=0;n<a;n++){let c=this.isobmffReader.readU64();i.sampleTable.chunkOffsets.push(c)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(t.contentSize);break;case"mehd":{let i=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let a=i===1?this.isobmffReader.readU64():this.isobmffReader.readU32();this.movieDurationInTimescale=a}break;case"trex":{this.isobmffReader.pos+=4;let i=this.isobmffReader.readU32(),a=this.isobmffReader.readU32(),n=this.isobmffReader.readU32(),c=this.isobmffReader.readU32(),o=this.isobmffReader.readU32();this.fragmentTrackDefaults.push({trackId:i,defaultSampleDescriptionIndex:a,defaultSampleDuration:n,defaultSampleSize:c,defaultSampleFlags:o})}break;case"tfra":{let i=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let a=this.isobmffReader.readU32(),n=this.tracks.find(w=>w.id===a);if(!n)break;n.fragmentLookupTable=[];let c=this.isobmffReader.readU32(),o=(c&48)>>4,u=(c&12)>>2,d=c&3,l=this.isobmffReader,g=[l.readU8.bind(l),l.readU16.bind(l),l.readU24.bind(l),l.readU32.bind(l)],h=g[o],b=g[u],p=g[d],x=this.isobmffReader.readU32();for(let w=0;w<x;w++){let y=i===1?this.isobmffReader.readU64():this.isobmffReader.readU32(),H=i===1?this.isobmffReader.readU64():this.isobmffReader.readU32(),ie=h(),V=b(),A=p();n.fragmentLookupTable.push({timestamp:y,moofOffset:H})}}break;case"moof":{this.currentFragment={moofOffset:e,moofSize:t.totalSize,implicitBaseDataOffset:e,trackData:new Map,dataStart:1/0,dataEnd:0,nextFragment:null},this.readContiguousBoxes(t.contentSize);let i=I(this.fragments,this.currentFragment.moofOffset,a=>a.moofOffset);this.fragments.splice(i+1,0,this.currentFragment);for(let[,a]of this.currentFragment.trackData){let n=a.samples[0],c=_(a.samples);this.currentFragment.dataStart=Math.min(this.currentFragment.dataStart,n.byteOffset),this.currentFragment.dataEnd=Math.max(this.currentFragment.dataEnd,c.byteOffset+c.byteSize)}this.currentFragment=null}break;case"traf":if(m(this.currentFragment),this.readContiguousBoxes(t.contentSize),this.currentTrack){let i=this.currentFragment.trackData.get(this.currentTrack.id);if(i){let a=I(this.currentTrack.fragments,this.currentFragment.moofOffset,c=>c.moofOffset);this.currentTrack.fragments.splice(a+1,0,this.currentFragment);let{currentFragmentState:n}=this.currentTrack;m(n),n.startTimestamp!==null&&(nr(i,n.startTimestamp),i.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{m(this.currentFragment),this.isobmffReader.pos+=1;let i=this.isobmffReader.readU24(),a=!!(i&1),n=!!(i&2),c=!!(i&8),o=!!(i&16),u=!!(i&32),d=!!(i&65536),l=!!(i&131072),g=this.isobmffReader.readU32(),h=this.tracks.find(p=>p.id===g);if(!h)break;let b=this.fragmentTrackDefaults.find(p=>p.trackId===g);this.currentTrack=h,h.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:b?.defaultSampleDescriptionIndex??null,defaultSampleDuration:b?.defaultSampleDuration??null,defaultSampleSize:b?.defaultSampleSize??null,defaultSampleFlags:b?.defaultSampleFlags??null,startTimestamp:null},a?h.currentFragmentState.baseDataOffset=this.isobmffReader.readU64():l&&(h.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),n&&(h.currentFragmentState.sampleDescriptionIndex=this.isobmffReader.readU32()),c&&(h.currentFragmentState.defaultSampleDuration=this.isobmffReader.readU32()),o&&(h.currentFragmentState.defaultSampleSize=this.isobmffReader.readU32()),u&&(h.currentFragmentState.defaultSampleFlags=this.isobmffReader.readU32()),d&&(h.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{let i=this.currentTrack;if(!i)break;m(i.currentFragmentState);let a=this.isobmffReader.readU8();this.isobmffReader.pos+=3;let n=a===0?this.isobmffReader.readU32():this.isobmffReader.readU64();i.currentFragmentState.startTimestamp=n}break;case"trun":{let i=this.currentTrack;if(!i)break;if(m(this.currentFragment),m(i.currentFragmentState),this.currentFragment.trackData.has(i.id))throw new Error("Can't have two trun boxes for the same track in one fragment.");let a=this.isobmffReader.readU8(),n=this.isobmffReader.readU24(),c=!!(n&1),o=!!(n&4),u=!!(n&256),d=!!(n&512),l=!!(n&1024),g=!!(n&2048),h=this.isobmffReader.readU32(),b=i.currentFragmentState.baseDataOffset;c&&(b+=this.isobmffReader.readI32());let p=null;o&&(p=this.isobmffReader.readU32());let x=b;if(h===0){this.currentFragment.implicitBaseDataOffset=x;break}let w=0,y={startTimestamp:0,endTimestamp:0,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(i.id,y);for(let V=0;V<h;V++){let A;u?A=this.isobmffReader.readU32():(m(i.currentFragmentState.defaultSampleDuration!==null),A=i.currentFragmentState.defaultSampleDuration);let Ie;d?Ie=this.isobmffReader.readU32():(m(i.currentFragmentState.defaultSampleSize!==null),Ie=i.currentFragmentState.defaultSampleSize);let _e;l?_e=this.isobmffReader.readU32():(m(i.currentFragmentState.defaultSampleFlags!==null),_e=i.currentFragmentState.defaultSampleFlags),V===0&&p!==null&&(_e=p);let ut=0;g&&(a===0?ut=this.isobmffReader.readU32():ut=this.isobmffReader.readI32());let dr=!(_e&65536);y.samples.push({presentationTimestamp:w+ut,duration:A,byteOffset:x,byteSize:Ie,isKeyFrame:dr}),x+=Ie,w+=A}y.presentationTimestamps=y.samples.map((V,A)=>({presentationTimestamp:V.presentationTimestamp,sampleIndex:A})).sort((V,A)=>V.presentationTimestamp-A.presentationTimestamp);let H=y.samples[y.presentationTimestamps[0].sampleIndex],ie=y.samples[_(y.presentationTimestamps).sampleIndex];y.startTimestamp=H.presentationTimestamp,y.endTimestamp=ie.presentationTimestamp+ie.duration,this.currentFragment.implicitBaseDataOffset=x}break}this.isobmffReader.pos=s}},it=class{constructor(e){this.internalTrack=e}chunkToSampleIndex=new WeakMap;sampleIndexToChunk=new Map;chunkToFragmentLocation=new WeakMap;fragmentLocationToChunk=new Map;getCodec(){throw new Error("Not implemented on base class.")}async getDuration(){return this.internalTrack.durationInTimescale/this.internalTrack.timescale}},Ct=class extends it{internalTrack;constructor(e){super(e),this.internalTrack=e}async getCodec(){return this.internalTrack.info.codec}async getWidth(){return this.internalTrack.info.width}async getHeight(){return this.internalTrack.info.height}async getRotation(){return this.internalTrack.rotation}async getDecoderConfig(){return{codec:Gt(this.internalTrack.info.codec,this.internalTrack.info.codecDescription),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}}async getFirstChunk(){return this.internalTrack.demuxer.isFragmented?this.performFragmentedLookup(()=>{let e=this.internalTrack.fragments[0];return{fragmentIndex:e?0:-1,sampleIndex:e?0:-1,correctSampleFound:!!e}},0,1/0):this.fetchChunkForSampleIndex(0)}async getChunk(e){let t=e*this.internalTrack.timescale;if(this.internalTrack.demuxer.isFragmented)return this.performFragmentedLookup(()=>this.findSampleInFragmentsForTimestamp(t),t,t);{let s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=ar(s,t);return this.fetchChunkForSampleIndex(i)}}async getNextChunk(e){if(this.internalTrack.demuxer.isFragmented){let s=this.chunkToFragmentLocation.get(e);if(s===void 0)throw new Error("Chunk was not created from this track.");let i=s.fragment.trackData.get(this.internalTrack.id),a=i.samples[s.sampleIndex],n=D(this.internalTrack.fragments,s.fragment.moofOffset,c=>c.moofOffset);return m(n!==-1),this.performFragmentedLookup(()=>{if(s.sampleIndex+1<i.samples.length)return{fragmentIndex:n,sampleIndex:s.sampleIndex+1,correctSampleFound:!0};{let c=s.fragment;for(;c.nextFragment;)if(c=c.nextFragment,c.trackData.get(this.internalTrack.id)){let u=D(this.internalTrack.fragments,c.moofOffset,d=>d.moofOffset);return m(u!==-1),{fragmentIndex:u,sampleIndex:0,correctSampleFound:!0}}return{fragmentIndex:n,sampleIndex:-1,correctSampleFound:!1}}},a.presentationTimestamp,1/0)}let t=this.chunkToSampleIndex.get(e);if(t===void 0)throw new Error("Chunk was not created from this track.");return this.fetchChunkForSampleIndex(t+1)}async getKeyChunk(e){let t=e*this.internalTrack.timescale;if(this.internalTrack.demuxer.isFragmented)return this.performFragmentedLookup(()=>this.findKeySampleInFragmentsForTimestamp(t),t,t);let s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=ar(s,t),a=i===-1?-1:Ii(s,i);return this.fetchChunkForSampleIndex(a)}async getNextKeyChunk(e){if(this.internalTrack.demuxer.isFragmented){let a=this.chunkToFragmentLocation.get(e);if(a===void 0)throw new Error("Chunk was not created from this track.");let n=a.fragment.trackData.get(this.internalTrack.id),c=n.samples[a.sampleIndex],o=D(this.internalTrack.fragments,a.fragment.moofOffset,u=>u.moofOffset);return m(o!==-1),this.performFragmentedLookup(()=>{let u=n.samples.findIndex((d,l)=>d.isKeyFrame&&l>a.sampleIndex);if(u!==-1)return{fragmentIndex:o,sampleIndex:u,correctSampleFound:!0};{let d=a.fragment;for(;d.nextFragment;){d=d.nextFragment;let l=d.trackData.get(this.internalTrack.id);if(l){let g=D(this.internalTrack.fragments,d.moofOffset,b=>b.moofOffset);m(g!==-1);let h=l.samples.findIndex(b=>b.isKeyFrame);if(h===-1)throw new Error("Not supported: Fragment does not contain key sample.");return{fragmentIndex:g,sampleIndex:h,correctSampleFound:!0}}}return{fragmentIndex:o,sampleIndex:-1,correctSampleFound:!1}}},c.presentationTimestamp,1/0)}let t=this.chunkToSampleIndex.get(e);if(t===void 0)throw new Error("Chunk was not created from this track.");let s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=_i(s,t);return this.fetchChunkForSampleIndex(i)}async fetchChunkForSampleIndex(e){if(e===-1)return null;let t=this.sampleIndexToChunk.get(e)?.deref();if(t)return t;let s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),i=vi(s,e);if(!i)return null;await this.internalTrack.demuxer.chunkReader.reader.loadRange(i.chunkOffset,i.chunkOffset+i.chunkSize);let a=this.internalTrack.demuxer.chunkReader.readRange(i.sampleOffset,i.sampleOffset+i.sampleSize),n=new EncodedVideoChunk({data:a,timestamp:1e6*i.presentationTimestamp/this.internalTrack.timescale,duration:1e6*i.duration/this.internalTrack.timescale,type:i.isKeyFrame?"key":"delta"});return this.chunkToSampleIndex.set(n,e),this.sampleIndexToChunk.set(e,new WeakRef(n)),n}async fetchChunkInFragment(e,t){if(t===-1)return null;let s=`${e.moofOffset}:${t}`,i=this.fragmentLocationToChunk.get(s)?.deref();if(i)return i;let n=e.trackData.get(this.internalTrack.id).samples[t];m(n),await this.internalTrack.demuxer.chunkReader.reader.loadRange(e.dataStart,e.dataEnd);let c=this.internalTrack.demuxer.chunkReader.readRange(n.byteOffset,n.byteOffset+n.byteSize),o=new EncodedVideoChunk({data:c,timestamp:1e6*n.presentationTimestamp/this.internalTrack.timescale,duration:1e6*n.duration/this.internalTrack.timescale,type:n.isKeyFrame?"key":"delta"});return this.chunkToFragmentLocation.set(o,{fragment:e,sampleIndex:t}),this.fragmentLocationToChunk.set(s,new WeakRef(o)),o}findSampleInFragmentsForTimestamp(e){let t=I(this.internalTrack.fragments,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp),s=-1,i=!1;if(t!==-1){let n=this.internalTrack.fragments[t].trackData.get(this.internalTrack.id),c=I(n.presentationTimestamps,e,o=>o.presentationTimestamp);m(c!==-1),s=n.presentationTimestamps[c].sampleIndex,i=e<n.endTimestamp}return{fragmentIndex:t,sampleIndex:s,correctSampleFound:i}}findKeySampleInFragmentsForTimestamp(e){let t=I(this.internalTrack.fragments,e,a=>a.trackData.get(this.internalTrack.id).startTimestamp),s=-1,i=!1;if(t!==-1){let n=this.internalTrack.fragments[t].trackData.get(this.internalTrack.id),c=n.presentationTimestamps.findLastIndex(u=>n.samples[u.sampleIndex].isKeyFrame);if(c===-1)throw new Error("Not supported: Fragment does not contain key sample.");s=n.presentationTimestamps[c].sampleIndex,i=e<n.endTimestamp}return{fragmentIndex:t,sampleIndex:s,correctSampleFound:i}}async performFragmentedLookup(e,t,s){let{fragmentIndex:i,sampleIndex:a,correctSampleFound:n}=e();if(n){let u=this.internalTrack.fragments[i];return this.fetchChunkInFragment(u,a)}let c=this.internalTrack.demuxer,o=await c.fragmentLookupMutex.acquire();try{let u=c.isobmffReader,d=await u.reader.source._getSize(),l=null,g=i,h=a,b=null;if(this.internalTrack.fragmentLookupTable){let p=I(this.internalTrack.fragmentLookupTable,t,x=>x.timestamp);p!==-1&&(b=this.internalTrack.fragmentLookupTable[p])}if(i===-1)u.pos=b?.moofOffset??0;else{let p=this.internalTrack.fragments[i];!b||p.moofOffset>=p.moofOffset?(u.pos=p.moofOffset+p.moofSize,l=p):u.pos=b.moofOffset}for(;u.pos<d;){if(l){let w=l.trackData.get(this.internalTrack.id);if(w&&w.startTimestamp>s)break;if(l.nextFragment){u.pos=l.nextFragment.moofOffset+l.nextFragment.moofSize,l=l.nextFragment;continue}}await u.reader.loadRange(u.pos,u.pos+16);let p=u.pos,x=u.readBoxHeader();if(x.name==="moof"){let w=D(c.fragments,p,y=>y.moofOffset);if(w===-1){u.pos=p;let y=await c.readFragment();l&&(l.nextFragment=y),l=y;let{fragmentIndex:H,sampleIndex:ie,correctSampleFound:V}=e();if(V){let A=this.internalTrack.fragments[H];return this.fetchChunkInFragment(A,ie)}H!==-1&&(g=H,h=ie)}else{let y=c.fragments[w];l&&(l.nextFragment=y),l=y}}u.pos=p+x.totalSize}if(g!==-1){let p=this.internalTrack.fragments[g];return this.fetchChunkInFragment(p,h)}return null}finally{o()}}},wt=class extends it{internalTrack;constructor(e){super(e),this.internalTrack=e}async getCodec(){return this.internalTrack.info.codec}async getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}async getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return{codec:Zt(this.internalTrack.info.codec,this.internalTrack.info.codecDescription),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}}},ar=(r,e)=>{let t=I(r.presentationTimestamps,e,s=>s.presentationTimestamp);return t===-1?-1:r.presentationTimestamps[t].sampleIndex},vi=(r,e)=>{let t=I(r.sampleTimingEntries,e,p=>p.startIndex),s=r.sampleTimingEntries[t];if(!s||s.startIndex+s.count<=e)return null;let a=s.startDecodeTimestamp+(e-s.startIndex)*s.delta,n=I(r.sampleCompositionTimeOffsets,e,p=>p.startIndex),c=r.sampleCompositionTimeOffsets[n];c&&(a+=c.offset);let o=r.sampleSizes[Math.min(e,r.sampleSizes.length-1)],u=I(r.sampleToChunk,e,p=>p.startSampleIndex),d=r.sampleToChunk[u];m(d);let l=d.startChunkIndex+Math.floor((e-d.startSampleIndex)/d.samplesPerChunk),g=r.chunkOffsets[l],h=0,b=g;if(r.sampleSizes.length===1)b+=o*(e-d.startSampleIndex),h+=o*d.samplesPerChunk;else{let p=d.startSampleIndex+(l-d.startChunkIndex)*d.samplesPerChunk;for(let x=p;x<p+d.samplesPerChunk;x++){let w=r.sampleSizes[x];x<e&&(b+=w),h+=w}}return{presentationTimestamp:a,duration:s.delta,sampleOffset:b,sampleSize:o,chunkOffset:g,chunkSize:h,isKeyFrame:r.keySampleIndices?D(r.keySampleIndices,e,p=>p)!==-1:!0}},Ii=(r,e)=>{if(!r.keySampleIndices)return e;let t=I(r.keySampleIndices,e,s=>s);return r.keySampleIndices[t]??-1},_i=(r,e)=>{if(!r.keySampleIndices)return e+1;let t=I(r.keySampleIndices,e,s=>s);return r.keySampleIndices[t+1]??-1},nr=(r,e)=>{r.startTimestamp+=e,r.endTimestamp+=e;for(let t of r.samples)t.presentationTimestamp+=e;for(let t of r.presentationTimestamps)t.presentationTimestamp+=e};var st=class extends me{};var at=class{},yt=class extends at{async _canReadInput(e){if(await e._mainReader.source._getSize()<8)return!1;let s=new re(e._mainReader);return s.pos=4,s.readAscii(4)==="ftyp"}_createDemuxer(e){return new rt(e)}},vt=class extends at{async _canReadInput(){return!1}_createDemuxer(e){return new st(e)}},ye=new yt,or=ye,cr=ye,nt=new vt,It=nt,ur=nt,mr=[ye,It];var ot=class{_source;_formats;_mainReader;_demuxerPromise=null;_format=null;constructor(e){this._formats=e.formats,this._source=e.source,this._mainReader=new de(e.source)}_getDemuxer(){return this._demuxerPromise??=(async()=>{await this._mainReader.loadRange(0,4096);for(let e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unrecognizable format.")})()}async getFormat(){return await this._getDemuxer(),m(this._format),this._format}async getDuration(){return(await this._getDemuxer()).getDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(t=>t.isVideoTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(t=>t.isVideoTrack())??null}async getAudioTracks(){return(await this.getTracks()).filter(t=>t.isAudioTrack())}async getPrimaryAudioTrack(){return(await this.getTracks()).find(t=>t.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}};var ve=class{constructor(e){this.videoTrack=e}getFirstChunk(){return this.videoTrack._backing.getFirstChunk()}getChunk(e){return this.videoTrack._backing.getChunk(e)}getNextChunk(e){return this.videoTrack._backing.getNextChunk(e)}getKeyChunk(e){return this.videoTrack._backing.getKeyChunk(e)}getNextKeyChunk(e){return this.videoTrack._backing.getNextKeyChunk(e)}async*chunks(e,t=1/0){let s=[],{promise:i,resolve:a}=X(),{promise:n,resolve:c}=X(),o=!1,u=[],d=()=>Math.max(2,u.length);(async()=>{let l=e??await this.getFirstChunk();for(;l&&!o&&!(l.timestamp/1e6>=t);){if(s.length>d()){({promise:n,resolve:c}=X()),await n;continue}s.push(l),a(),{promise:i,resolve:a}=X(),l=await this.getNextChunk(l)}o=!0,a()})();try{for(;;)if(s.length>0){yield s.shift();let l=performance.now();for(u.push(l);u.length>0&&l-u[0]>=1e3;)u.shift();c()}else if(!o)await i;else break}finally{o=!0,c()}}},ct=class{constructor(e){this.videoTrack=e}decoderConfig=null;async createDecoder(e){this.decoderConfig||(this.decoderConfig=await this.videoTrack.getDecoderConfig());let t=new VideoDecoder({output:e,error:s=>console.error(s)});return t.configure(this.decoderConfig),t}async getKeyFrame(e){let t=null,s=await this.createDecoder(a=>t=a),i=await this.videoTrack._backing.getKeyChunk(e);return i?(s.decode(i),await s.flush(),s.close(),t):null}async getFrame(e){let t=null,s=await this.createDecoder(c=>{c.timestamp/1e6<=e?(t?.close(),t=c):c.close()}),i=await this.videoTrack._backing.getKeyChunk(e);if(!i)return null;let a=await this.videoTrack._backing.getChunk(e);m(a),s.decode(i);let n=i;for(;n!==a;){let c=await this.videoTrack._backing.getNextChunk(n);m(c),n=c,s.decode(c),s.decodeQueueSize>=10&&await new Promise(o=>s.addEventListener("dequeue",o,{once:!0}))}return await s.flush(),s.close(),t}async*frames(e=0,t=1/0){let s=[],i=!1,a=null,{promise:n,resolve:c}=X(),o=!1,u=await this.createDecoder(g=>{let h=g.timestamp/1e6;if(h>=t&&(o=!0),o){g.close();return}a&&(h>e?(s.push(a),i=!0):a.close()),h>=e&&(s.push(g),i=!0),a=i?null:g,s.length>0&&(c(),{promise:n,resolve:c}=X())}),d=await this.videoTrack._backing.getKeyChunk(e)??await this.videoTrack._backing.getFirstChunk();if(!d)return;let l=!1;(async()=>{let g=d,h=1/0;if(t<1/0){let x=await this.videoTrack._backing.getChunk(t),w=x?x.type==="key"&&x.timestamp/1e6===t?x:await this.videoTrack._backing.getNextKeyChunk(x):null;w&&(h=w.timestamp/1e6)}let p=new ve(this.videoTrack).chunks(d,h);for(await p.next();g&&!o;){u.decode(g),u.decodeQueueSize>=10&&await new Promise(w=>u.addEventListener("dequeue",w,{once:!0}));let x=await p.next();if(x.done)break;g=x.value}await p.return(),await u.flush(),u.close(),!i&&a&&s.push(a),l=!0,c()})();try{for(;;)if(s.length>0)yield s.shift();else if(!l)await n;else break}finally{o=!0}}};return gr(Ri);})();
if (typeof module === "object" && typeof module.exports === "object") Object.assign(module.exports, Metamuxer)
